// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.28.3
// source: nebius/mk8s/v1/node_group.proto

package v1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	_ "github.com/nebius/gosdk/proto/nebius"
	v1 "github.com/nebius/gosdk/proto/nebius/common/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type AttachedFilesystemSpec_AttachMode int32

const (
	AttachedFilesystemSpec_UNSPECIFIED AttachedFilesystemSpec_AttachMode = 0
	AttachedFilesystemSpec_READ_ONLY   AttachedFilesystemSpec_AttachMode = 1
	AttachedFilesystemSpec_READ_WRITE  AttachedFilesystemSpec_AttachMode = 2
)

// Enum value maps for AttachedFilesystemSpec_AttachMode.
var (
	AttachedFilesystemSpec_AttachMode_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "READ_ONLY",
		2: "READ_WRITE",
	}
	AttachedFilesystemSpec_AttachMode_value = map[string]int32{
		"UNSPECIFIED": 0,
		"READ_ONLY":   1,
		"READ_WRITE":  2,
	}
)

func (x AttachedFilesystemSpec_AttachMode) Enum() *AttachedFilesystemSpec_AttachMode {
	p := new(AttachedFilesystemSpec_AttachMode)
	*p = x
	return p
}

func (x AttachedFilesystemSpec_AttachMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AttachedFilesystemSpec_AttachMode) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_mk8s_v1_node_group_proto_enumTypes[0].Descriptor()
}

func (AttachedFilesystemSpec_AttachMode) Type() protoreflect.EnumType {
	return &file_nebius_mk8s_v1_node_group_proto_enumTypes[0]
}

func (x AttachedFilesystemSpec_AttachMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AttachedFilesystemSpec_AttachMode.Descriptor instead.
func (AttachedFilesystemSpec_AttachMode) EnumDescriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{8, 0}
}

type NodeTaint_Effect int32

const (
	NodeTaint_EFFECT_UNSPECIFIED NodeTaint_Effect = 0
	NodeTaint_NO_EXECUTE         NodeTaint_Effect = 1
	NodeTaint_NO_SCHEDULE        NodeTaint_Effect = 2
	NodeTaint_PREFER_NO_SCHEDULE NodeTaint_Effect = 3
)

// Enum value maps for NodeTaint_Effect.
var (
	NodeTaint_Effect_name = map[int32]string{
		0: "EFFECT_UNSPECIFIED",
		1: "NO_EXECUTE",
		2: "NO_SCHEDULE",
		3: "PREFER_NO_SCHEDULE",
	}
	NodeTaint_Effect_value = map[string]int32{
		"EFFECT_UNSPECIFIED": 0,
		"NO_EXECUTE":         1,
		"NO_SCHEDULE":        2,
		"PREFER_NO_SCHEDULE": 3,
	}
)

func (x NodeTaint_Effect) Enum() *NodeTaint_Effect {
	p := new(NodeTaint_Effect)
	*p = x
	return p
}

func (x NodeTaint_Effect) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeTaint_Effect) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_mk8s_v1_node_group_proto_enumTypes[1].Descriptor()
}

func (NodeTaint_Effect) Type() protoreflect.EnumType {
	return &file_nebius_mk8s_v1_node_group_proto_enumTypes[1]
}

func (x NodeTaint_Effect) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeTaint_Effect.Descriptor instead.
func (NodeTaint_Effect) EnumDescriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{11, 0}
}

type NodeGroupStatus_State int32

const (
	NodeGroupStatus_STATE_UNSPECIFIED NodeGroupStatus_State = 0
	NodeGroupStatus_PROVISIONING      NodeGroupStatus_State = 1
	NodeGroupStatus_RUNNING           NodeGroupStatus_State = 2
	NodeGroupStatus_DELETING          NodeGroupStatus_State = 3
)

// Enum value maps for NodeGroupStatus_State.
var (
	NodeGroupStatus_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "PROVISIONING",
		2: "RUNNING",
		3: "DELETING",
	}
	NodeGroupStatus_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"PROVISIONING":      1,
		"RUNNING":           2,
		"DELETING":          3,
	}
)

func (x NodeGroupStatus_State) Enum() *NodeGroupStatus_State {
	p := new(NodeGroupStatus_State)
	*p = x
	return p
}

func (x NodeGroupStatus_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeGroupStatus_State) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_mk8s_v1_node_group_proto_enumTypes[2].Descriptor()
}

func (NodeGroupStatus_State) Type() protoreflect.EnumType {
	return &file_nebius_mk8s_v1_node_group_proto_enumTypes[2]
}

func (x NodeGroupStatus_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeGroupStatus_State.Descriptor instead.
func (NodeGroupStatus_State) EnumDescriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{15, 0}
}

// NodeGroup represents Kubernetes node pool - set of worker machines having the same configuration.
// A Node is a Nebius Compute Instance created in Cluster.metadata.parent_id container, running kubelet
// that registers in Kubernetes API and a Node object created.
type NodeGroup struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Metadata      *v1.ResourceMetadata   `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"` // The parent_id is an ID of Cluster
	Spec          *NodeGroupSpec         `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	Status        *NodeGroupStatus       `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGroup) Reset() {
	*x = NodeGroup{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGroup) ProtoMessage() {}

func (x *NodeGroup) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGroup.ProtoReflect.Descriptor instead.
func (*NodeGroup) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{0}
}

func (x *NodeGroup) GetMetadata() *v1.ResourceMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *NodeGroup) GetSpec() *NodeGroupSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *NodeGroup) GetStatus() *NodeGroupStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type NodeGroupSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version is desired Kubernetes version of the cluster. For now only acceptable format is
	// `<major>.<minor>` like "1.31". Option for patch version update will be added later.
	// By default the cluster control plane <major>.<minor> version will be used.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Types that are valid to be assigned to Size:
	//
	//	*NodeGroupSpec_FixedNodeCount
	//	*NodeGroupSpec_Autoscaling
	Size isNodeGroupSpec_Size `protobuf_oneof:"size"`
	// Parameters for Kubernetes Node object and Nebius Compute Instance
	// If not written opposite a NodeTemplate field update will cause NodeGroup roll-out according NodeGroupDeploymentStrategy.
	Template *NodeTemplate `protobuf:"bytes,3,opt,name=template,proto3" json:"template,omitempty"`
	// Defines deployment - roll-out, or nodes re-creation during configuration change.
	// Allows to setup compromise in roll-out speed, extra resources consumption and workloads disruption.
	Strategy      *NodeGroupDeploymentStrategy `protobuf:"bytes,4,opt,name=strategy,proto3" json:"strategy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGroupSpec) Reset() {
	*x = NodeGroupSpec{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGroupSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGroupSpec) ProtoMessage() {}

func (x *NodeGroupSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGroupSpec.ProtoReflect.Descriptor instead.
func (*NodeGroupSpec) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{1}
}

func (x *NodeGroupSpec) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *NodeGroupSpec) GetSize() isNodeGroupSpec_Size {
	if x != nil {
		return x.Size
	}
	return nil
}

func (x *NodeGroupSpec) GetFixedNodeCount() int64 {
	if x != nil {
		if x, ok := x.Size.(*NodeGroupSpec_FixedNodeCount); ok {
			return x.FixedNodeCount
		}
	}
	return 0
}

func (x *NodeGroupSpec) GetAutoscaling() *NodeGroupAutoscalingSpec {
	if x != nil {
		if x, ok := x.Size.(*NodeGroupSpec_Autoscaling); ok {
			return x.Autoscaling
		}
	}
	return nil
}

func (x *NodeGroupSpec) GetTemplate() *NodeTemplate {
	if x != nil {
		return x.Template
	}
	return nil
}

func (x *NodeGroupSpec) GetStrategy() *NodeGroupDeploymentStrategy {
	if x != nil {
		return x.Strategy
	}
	return nil
}

type isNodeGroupSpec_Size interface {
	isNodeGroupSpec_Size()
}

type NodeGroupSpec_FixedNodeCount struct {
	// Number of nodes in the group. Can be changed manually at any time.
	FixedNodeCount int64 `protobuf:"varint,2,opt,name=fixed_node_count,json=fixedNodeCount,proto3,oneof"`
}

type NodeGroupSpec_Autoscaling struct {
	// Enables [Kubernetes Cluster Autoscaler](https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler)
	// for that NodeGroup, and defines autoscaling parameters.
	Autoscaling *NodeGroupAutoscalingSpec `protobuf:"bytes,5,opt,name=autoscaling,proto3,oneof"`
}

func (*NodeGroupSpec_FixedNodeCount) isNodeGroupSpec_Size() {}

func (*NodeGroupSpec_Autoscaling) isNodeGroupSpec_Size() {}

type NodeTemplate struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Metadata *NodeMetadataTemplate  `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Kubernetes Node taints.
	// For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
	// That behaviour may change later.
	// So, for now you will need to manually set them to existing nodes, if that is needed.
	// Field change will NOT trigger NodeGroup roll out.
	Taints []*NodeTaint `protobuf:"bytes,2,rep,name=taints,proto3" json:"taints,omitempty"`
	// Resources that will have Nebius Compute Instance where Node kubelet will run.
	Resources *ResourcesSpec `protobuf:"bytes,3,opt,name=resources,proto3" json:"resources,omitempty"`
	// Parameters of a Node Nebius Compute Instance boot disk.
	BootDisk *DiskSpec `protobuf:"bytes,9,opt,name=boot_disk,json=bootDisk,proto3" json:"boot_disk,omitempty"`
	// GPU-related settings.
	GpuSettings *GpuSettings `protobuf:"bytes,13,opt,name=gpu_settings,json=gpuSettings,proto3" json:"gpu_settings,omitempty"`
	// OS version that will be used to create the boot disk of Compute Instances in the NodeGroup.
	// Supported platform / k8s version /  OS / driver presets combinations
	//
	//	gpu-l40s-a, gpu-l40s-d, gpu-h100-sxm, gpu-h200-sxm, cpu-e1, cpu-e2, cpu-d3:
	//	  drivers_preset: ""
	//	    k8s: 1.30 → "ubuntu22.04"
	//	    k8s: 1.31 → "ubuntu22.04" (default), "ubuntu24.04"
	//	gpu-l40s-a, gpu-l40s-d, gpu-h100-sxm, gpu-h200-sxm:
	//	  drivers_preset: "cuda12" (CUDA 12.4)
	//	    k8s: 1.30, 1.31 → "ubuntu22.04"
	//	  drivers_preset: "cuda12.4"
	//	    k8s: 1.31 → "ubuntu22.04"
	//	  drivers_preset: "cuda12.8"
	//	    k8s: 1.31 → "ubuntu24.04"
	//	gpu-b200-sxm:
	//	  drivers_preset: ""
	//	    k8s: 1.30, 1.31 → "ubuntu24.04"
	//	  drivers_preset: "cuda12" (CUDA 12.8)
	//	    k8s: 1.30, 1.31 → "ubuntu24.04"
	//	  drivers_preset: "cuda12.8"
	//	    k8s: 1.31 → "ubuntu24.04"
	Os string `protobuf:"bytes,16,opt,name=os,proto3" json:"os,omitempty"`
	// Nebius Compute GPUCluster ID that will be attached to node.
	GpuCluster        *GpuClusterSpec             `protobuf:"bytes,4,opt,name=gpu_cluster,json=gpuCluster,proto3" json:"gpu_cluster,omitempty"`
	NetworkInterfaces []*NetworkInterfaceTemplate `protobuf:"bytes,5,rep,name=network_interfaces,json=networkInterfaces,proto3" json:"network_interfaces,omitempty"`
	// Static attachments of Compute Filesystem.
	// Can be used as a workaround, until CSI for Compute Disk and Filesystem will be available.
	Filesystems []*AttachedFilesystemSpec `protobuf:"bytes,7,rep,name=filesystems,proto3" json:"filesystems,omitempty"`
	// cloud-init user-data
	// Should contain at least one SSH key.
	CloudInitUserData string `protobuf:"bytes,6,opt,name=cloud_init_user_data,json=cloudInitUserData,proto3" json:"cloud_init_user_data,omitempty"`
	// the Nebius service account whose credentials will be available on the nodes of the group.
	// With these credentials, it is possible to make `nebius` CLI or public API requests from the nodes without the need for extra authentication.
	// This service account is also used to make requests to container registry.
	//
	// `resource.serviceaccount.issueAccessToken` permission is required to use this field.
	ServiceAccountId string `protobuf:"bytes,10,opt,name=service_account_id,json=serviceAccountId,proto3" json:"service_account_id,omitempty"`
	// Configures whether the nodes in the group are preemptible.
	// Set to empty value to enable preemptible nodes.
	Preemptible   *PreemptibleSpec `protobuf:"bytes,15,opt,name=preemptible,proto3" json:"preemptible,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeTemplate) Reset() {
	*x = NodeTemplate{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeTemplate) ProtoMessage() {}

func (x *NodeTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeTemplate.ProtoReflect.Descriptor instead.
func (*NodeTemplate) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{2}
}

func (x *NodeTemplate) GetMetadata() *NodeMetadataTemplate {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *NodeTemplate) GetTaints() []*NodeTaint {
	if x != nil {
		return x.Taints
	}
	return nil
}

func (x *NodeTemplate) GetResources() *ResourcesSpec {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *NodeTemplate) GetBootDisk() *DiskSpec {
	if x != nil {
		return x.BootDisk
	}
	return nil
}

func (x *NodeTemplate) GetGpuSettings() *GpuSettings {
	if x != nil {
		return x.GpuSettings
	}
	return nil
}

func (x *NodeTemplate) GetOs() string {
	if x != nil {
		return x.Os
	}
	return ""
}

func (x *NodeTemplate) GetGpuCluster() *GpuClusterSpec {
	if x != nil {
		return x.GpuCluster
	}
	return nil
}

func (x *NodeTemplate) GetNetworkInterfaces() []*NetworkInterfaceTemplate {
	if x != nil {
		return x.NetworkInterfaces
	}
	return nil
}

func (x *NodeTemplate) GetFilesystems() []*AttachedFilesystemSpec {
	if x != nil {
		return x.Filesystems
	}
	return nil
}

func (x *NodeTemplate) GetCloudInitUserData() string {
	if x != nil {
		return x.CloudInitUserData
	}
	return ""
}

func (x *NodeTemplate) GetServiceAccountId() string {
	if x != nil {
		return x.ServiceAccountId
	}
	return ""
}

func (x *NodeTemplate) GetPreemptible() *PreemptibleSpec {
	if x != nil {
		return x.Preemptible
	}
	return nil
}

type NodeMetadataTemplate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Kubernetes Node labels.
	// For now change will not be propagated to existing nodes, so will be applied only to Kubernetes Nodes created after the field change.
	// That behaviour may change later.
	// So, for now you will need to manually set them to existing nodes, if that is needed.
	//
	// System labels containing "kubernetes.io" and "k8s.io" will be ignored.
	// Field change will NOT trigger NodeGroup roll out.
	Labels        map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeMetadataTemplate) Reset() {
	*x = NodeMetadataTemplate{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeMetadataTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeMetadataTemplate) ProtoMessage() {}

func (x *NodeMetadataTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeMetadataTemplate.ProtoReflect.Descriptor instead.
func (*NodeMetadataTemplate) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{3}
}

func (x *NodeMetadataTemplate) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

// GPU-related settings.
type GpuSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
	// Supported presets for different platform / k8s version combinations:
	//
	//	gpu-l40s-a, gpu-l40s-d, gpu-h100-sxm, gpu-h200-sxm:
	//	  k8s: 1.30 → "cuda12" (CUDA 12.4)
	//	  k8s: 1.31 → "cuda12" (CUDA 12.4), "cuda12.4", "cuda12.8"
	//	gpu-b200-sxm:
	//	  k8s: 1.31 → "cuda12" (CUDA 12.8), "cuda12.8"
	DriversPreset string `protobuf:"bytes,1,opt,name=drivers_preset,json=driversPreset,proto3" json:"drivers_preset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GpuSettings) Reset() {
	*x = GpuSettings{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GpuSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GpuSettings) ProtoMessage() {}

func (x *GpuSettings) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GpuSettings.ProtoReflect.Descriptor instead.
func (*GpuSettings) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{4}
}

func (x *GpuSettings) GetDriversPreset() string {
	if x != nil {
		return x.DriversPreset
	}
	return ""
}

type GpuClusterSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GpuClusterSpec) Reset() {
	*x = GpuClusterSpec{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GpuClusterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GpuClusterSpec) ProtoMessage() {}

func (x *GpuClusterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GpuClusterSpec.ProtoReflect.Descriptor instead.
func (*GpuClusterSpec) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{5}
}

func (x *GpuClusterSpec) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type NetworkInterfaceTemplate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Parameters for Public IPv4 address associated with the interface.
	// Set to empty value, to enable it.
	PublicIpAddress *PublicIPAddress `protobuf:"bytes,1,opt,name=public_ip_address,json=publicIpAddress,proto3" json:"public_ip_address,omitempty"`
	// Nebius VPC Subnet ID that will be attached to a node cloud instance network interface.
	// By default Cluster control plane subnet_id used.
	// Subnet should be located in the same network with control plane.
	SubnetId      string `protobuf:"bytes,3,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkInterfaceTemplate) Reset() {
	*x = NetworkInterfaceTemplate{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkInterfaceTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkInterfaceTemplate) ProtoMessage() {}

func (x *NetworkInterfaceTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkInterfaceTemplate.ProtoReflect.Descriptor instead.
func (*NetworkInterfaceTemplate) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{6}
}

func (x *NetworkInterfaceTemplate) GetPublicIpAddress() *PublicIPAddress {
	if x != nil {
		return x.PublicIpAddress
	}
	return nil
}

func (x *NetworkInterfaceTemplate) GetSubnetId() string {
	if x != nil {
		return x.SubnetId
	}
	return ""
}

// Describes a public IP address.
type PublicIPAddress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublicIPAddress) Reset() {
	*x = PublicIPAddress{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicIPAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicIPAddress) ProtoMessage() {}

func (x *PublicIPAddress) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicIPAddress.ProtoReflect.Descriptor instead.
func (*PublicIPAddress) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{7}
}

type AttachedFilesystemSpec struct {
	state      protoimpl.MessageState            `protogen:"open.v1"`
	AttachMode AttachedFilesystemSpec_AttachMode `protobuf:"varint,1,opt,name=attach_mode,json=attachMode,proto3,enum=nebius.mk8s.v1.AttachedFilesystemSpec_AttachMode" json:"attach_mode,omitempty"`
	// Specifies the user-defined identifier, allowing to use it as a device in mount command.
	MountTag string `protobuf:"bytes,2,opt,name=mount_tag,json=mountTag,proto3" json:"mount_tag,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*AttachedFilesystemSpec_ExistingFilesystem
	Type          isAttachedFilesystemSpec_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttachedFilesystemSpec) Reset() {
	*x = AttachedFilesystemSpec{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttachedFilesystemSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachedFilesystemSpec) ProtoMessage() {}

func (x *AttachedFilesystemSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachedFilesystemSpec.ProtoReflect.Descriptor instead.
func (*AttachedFilesystemSpec) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{8}
}

func (x *AttachedFilesystemSpec) GetAttachMode() AttachedFilesystemSpec_AttachMode {
	if x != nil {
		return x.AttachMode
	}
	return AttachedFilesystemSpec_UNSPECIFIED
}

func (x *AttachedFilesystemSpec) GetMountTag() string {
	if x != nil {
		return x.MountTag
	}
	return ""
}

func (x *AttachedFilesystemSpec) GetType() isAttachedFilesystemSpec_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *AttachedFilesystemSpec) GetExistingFilesystem() *ExistingFilesystem {
	if x != nil {
		if x, ok := x.Type.(*AttachedFilesystemSpec_ExistingFilesystem); ok {
			return x.ExistingFilesystem
		}
	}
	return nil
}

type isAttachedFilesystemSpec_Type interface {
	isAttachedFilesystemSpec_Type()
}

type AttachedFilesystemSpec_ExistingFilesystem struct {
	ExistingFilesystem *ExistingFilesystem `protobuf:"bytes,3,opt,name=existing_filesystem,json=existingFilesystem,proto3,oneof"`
}

func (*AttachedFilesystemSpec_ExistingFilesystem) isAttachedFilesystemSpec_Type() {}

type ExistingFilesystem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExistingFilesystem) Reset() {
	*x = ExistingFilesystem{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExistingFilesystem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExistingFilesystem) ProtoMessage() {}

func (x *ExistingFilesystem) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExistingFilesystem.ProtoReflect.Descriptor instead.
func (*ExistingFilesystem) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{9}
}

func (x *ExistingFilesystem) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type NodeGroupAutoscalingSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MinNodeCount  int64                  `protobuf:"varint,1,opt,name=min_node_count,json=minNodeCount,proto3" json:"min_node_count,omitempty"`
	MaxNodeCount  int64                  `protobuf:"varint,2,opt,name=max_node_count,json=maxNodeCount,proto3" json:"max_node_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGroupAutoscalingSpec) Reset() {
	*x = NodeGroupAutoscalingSpec{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGroupAutoscalingSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGroupAutoscalingSpec) ProtoMessage() {}

func (x *NodeGroupAutoscalingSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGroupAutoscalingSpec.ProtoReflect.Descriptor instead.
func (*NodeGroupAutoscalingSpec) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{10}
}

func (x *NodeGroupAutoscalingSpec) GetMinNodeCount() int64 {
	if x != nil {
		return x.MinNodeCount
	}
	return 0
}

func (x *NodeGroupAutoscalingSpec) GetMaxNodeCount() int64 {
	if x != nil {
		return x.MaxNodeCount
	}
	return 0
}

// See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
type NodeTaint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Effect        NodeTaint_Effect       `protobuf:"varint,3,opt,name=effect,proto3,enum=nebius.mk8s.v1.NodeTaint_Effect" json:"effect,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeTaint) Reset() {
	*x = NodeTaint{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeTaint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeTaint) ProtoMessage() {}

func (x *NodeTaint) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeTaint.ProtoReflect.Descriptor instead.
func (*NodeTaint) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{11}
}

func (x *NodeTaint) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *NodeTaint) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *NodeTaint) GetEffect() NodeTaint_Effect {
	if x != nil {
		return x.Effect
	}
	return NodeTaint_EFFECT_UNSPECIFIED
}

type NodeGroupDeploymentStrategy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum number of nodes that can be simultaneously unavailable during the update process.
	// This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
	// When specified as a percentage, the actual number is calculated by rounding down to the nearest whole number.
	// This value cannot be 0 if `max_surge` is also set to 0.
	// Defaults to 0.
	// Example: If set to 20%, up to 20% of the nodes can be taken offline at once during the update,
	// ensuring that at least 80% of the desired nodes remain operational.
	MaxUnavailable *PercentOrCount `protobuf:"bytes,1,opt,name=max_unavailable,json=maxUnavailable,proto3" json:"max_unavailable,omitempty"`
	// The maximum number of additional nodes that can be provisioned above the desired number of nodes during the update process.
	// This value can be specified either as an absolute number (for example 3) or as a percentage of the desired number of nodes (for example 5%).
	// When specified as a percentage, the actual number is calculated by rounding up to the nearest whole number.
	// This value cannot be 0 if `max_unavailable` is also set to 0.
	// Defaults to 1.
	// Example: If set to 25%, the node group can scale up by an additional 25% during the update,
	// allowing new nodes to be added before old nodes are removed, which helps minimize workload disruption.
	// NOTE: it is user responsibility to ensure that there are enough quota for provision nodes above the desired number.
	//
	//	Available quota effectively limits `max_surge`.
	//	In case of not enough quota even for one extra node, update operation will hung because of quota exhausted error.
	//	Such error will be visible in Operation.progress_data.
	MaxSurge *PercentOrCount `protobuf:"bytes,2,opt,name=max_surge,json=maxSurge,proto3" json:"max_surge,omitempty"`
	// Maximum amount of time that the service will spend on attempting gracefully draining a node (evicting it's pods), before
	// falling back to pod deletion.
	// By default, node can be drained unlimited time.
	// Important consequence of that is if PodDisruptionBudget doesn't allow to evict a pod,
	// then NodeGroup update with node re-creation will hung on that pod eviction.
	// Note, that it is different from `kubectl drain --timeout`
	DrainTimeout  *durationpb.Duration `protobuf:"bytes,3,opt,name=drain_timeout,json=drainTimeout,proto3" json:"drain_timeout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGroupDeploymentStrategy) Reset() {
	*x = NodeGroupDeploymentStrategy{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGroupDeploymentStrategy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGroupDeploymentStrategy) ProtoMessage() {}

func (x *NodeGroupDeploymentStrategy) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGroupDeploymentStrategy.ProtoReflect.Descriptor instead.
func (*NodeGroupDeploymentStrategy) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{12}
}

func (x *NodeGroupDeploymentStrategy) GetMaxUnavailable() *PercentOrCount {
	if x != nil {
		return x.MaxUnavailable
	}
	return nil
}

func (x *NodeGroupDeploymentStrategy) GetMaxSurge() *PercentOrCount {
	if x != nil {
		return x.MaxSurge
	}
	return nil
}

func (x *NodeGroupDeploymentStrategy) GetDrainTimeout() *durationpb.Duration {
	if x != nil {
		return x.DrainTimeout
	}
	return nil
}

type PercentOrCount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*PercentOrCount_Percent
	//	*PercentOrCount_Count
	Value         isPercentOrCount_Value `protobuf_oneof:"value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PercentOrCount) Reset() {
	*x = PercentOrCount{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PercentOrCount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PercentOrCount) ProtoMessage() {}

func (x *PercentOrCount) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PercentOrCount.ProtoReflect.Descriptor instead.
func (*PercentOrCount) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{13}
}

func (x *PercentOrCount) GetValue() isPercentOrCount_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *PercentOrCount) GetPercent() int64 {
	if x != nil {
		if x, ok := x.Value.(*PercentOrCount_Percent); ok {
			return x.Percent
		}
	}
	return 0
}

func (x *PercentOrCount) GetCount() int64 {
	if x != nil {
		if x, ok := x.Value.(*PercentOrCount_Count); ok {
			return x.Count
		}
	}
	return 0
}

type isPercentOrCount_Value interface {
	isPercentOrCount_Value()
}

type PercentOrCount_Percent struct {
	Percent int64 `protobuf:"varint,1,opt,name=percent,proto3,oneof"`
}

type PercentOrCount_Count struct {
	Count int64 `protobuf:"varint,2,opt,name=count,proto3,oneof"`
}

func (*PercentOrCount_Percent) isPercentOrCount_Value() {}

func (*PercentOrCount_Count) isPercentOrCount_Value() {}

type PreemptibleSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PreemptibleSpec) Reset() {
	*x = PreemptibleSpec{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PreemptibleSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreemptibleSpec) ProtoMessage() {}

func (x *PreemptibleSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreemptibleSpec.ProtoReflect.Descriptor instead.
func (*PreemptibleSpec) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{14}
}

type NodeGroupStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	State NodeGroupStatus_State  `protobuf:"varint,1,opt,name=state,proto3,enum=nebius.mk8s.v1.NodeGroupStatus_State" json:"state,omitempty"`
	// Actual version of NodeGroup. Have format `<major>.<minor>.<patch>-nebius-node.<infra_version>` like "1.30.0-nebius-node.10".
	// Where <major>.<minor>.<patch> is Kubernetes version and <infra_version> is version of Node infrastructure and configuration,
	// which update may include bug fixes, security updates and new features depending on worker node configuration.
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Desired total number of nodes that should be in the node group.
	// It is either `NodeGroupSpec.fixed_node_count` or arbitrary number between
	// `NodeGroupAutoscalingSpec.min_node_count` and `NodeGroupAutoscalingSpec.max_node_count` decided by autoscaler.
	TargetNodeCount int64 `protobuf:"varint,3,opt,name=target_node_count,json=targetNodeCount,proto3" json:"target_node_count,omitempty"`
	// Total number of nodes that are currently in the node group.
	// Both ready and not ready nodes are counted.
	NodeCount int64 `protobuf:"varint,4,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// Total number of nodes that has outdated node configuration.
	// These nodes will be replaced by new nodes with up-to-date configuration.
	OutdatedNodeCount int64 `protobuf:"varint,5,opt,name=outdated_node_count,json=outdatedNodeCount,proto3" json:"outdated_node_count,omitempty"`
	// Total number of nodes that successfully joined the cluster and are ready to serve workloads.
	// Both outdated and up-to-date nodes are counted.
	ReadyNodeCount int64 `protobuf:"varint,6,opt,name=ready_node_count,json=readyNodeCount,proto3" json:"ready_node_count,omitempty"`
	// Deprecated: Marked as deprecated in nebius/mk8s/v1/node_group.proto.
	Conditions []*Condition                 `protobuf:"bytes,50,rep,name=conditions,proto3" json:"conditions,omitempty"`
	Events     []*v1.RecurrentResourceEvent `protobuf:"bytes,61,rep,name=events,proto3" json:"events,omitempty"`
	// Show that there are changes are in flight.
	Reconciling   bool `protobuf:"varint,100,opt,name=reconciling,proto3" json:"reconciling,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGroupStatus) Reset() {
	*x = NodeGroupStatus{}
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGroupStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGroupStatus) ProtoMessage() {}

func (x *NodeGroupStatus) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1_node_group_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGroupStatus.ProtoReflect.Descriptor instead.
func (*NodeGroupStatus) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1_node_group_proto_rawDescGZIP(), []int{15}
}

func (x *NodeGroupStatus) GetState() NodeGroupStatus_State {
	if x != nil {
		return x.State
	}
	return NodeGroupStatus_STATE_UNSPECIFIED
}

func (x *NodeGroupStatus) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *NodeGroupStatus) GetTargetNodeCount() int64 {
	if x != nil {
		return x.TargetNodeCount
	}
	return 0
}

func (x *NodeGroupStatus) GetNodeCount() int64 {
	if x != nil {
		return x.NodeCount
	}
	return 0
}

func (x *NodeGroupStatus) GetOutdatedNodeCount() int64 {
	if x != nil {
		return x.OutdatedNodeCount
	}
	return 0
}

func (x *NodeGroupStatus) GetReadyNodeCount() int64 {
	if x != nil {
		return x.ReadyNodeCount
	}
	return 0
}

// Deprecated: Marked as deprecated in nebius/mk8s/v1/node_group.proto.
func (x *NodeGroupStatus) GetConditions() []*Condition {
	if x != nil {
		return x.Conditions
	}
	return nil
}

func (x *NodeGroupStatus) GetEvents() []*v1.RecurrentResourceEvent {
	if x != nil {
		return x.Events
	}
	return nil
}

func (x *NodeGroupStatus) GetReconciling() bool {
	if x != nil {
		return x.Reconciling
	}
	return false
}

var File_nebius_mk8s_v1_node_group_proto protoreflect.FileDescriptor

const file_nebius_mk8s_v1_node_group_proto_rawDesc = "" +
	"\n" +
	"\x1fnebius/mk8s/v1/node_group.proto\x12\x0enebius.mk8s.v1\x1a\x1bbuf/validate/validate.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x18nebius/annotations.proto\x1a\x1fnebius/common/v1/metadata.proto\x1a%nebius/common/v1/resource_event.proto\x1a&nebius/mk8s/v1/instance_template.proto\x1a\x1enebius/mk8s/v1/condition.proto\"\xb7\x01\n" +
	"\tNodeGroup\x12>\n" +
	"\bmetadata\x18\x01 \x01(\v2\".nebius.common.v1.ResourceMetadataR\bmetadata\x121\n" +
	"\x04spec\x18\x02 \x01(\v2\x1d.nebius.mk8s.v1.NodeGroupSpecR\x04spec\x127\n" +
	"\x06status\x18\x03 \x01(\v2\x1f.nebius.mk8s.v1.NodeGroupStatusR\x06status\"\xdc\x02\n" +
	"\rNodeGroupSpec\x12,\n" +
	"\aversion\x18\x01 \x01(\tB\x12\xbaH\x0fr\r2\v|^\\d\\.\\d\\d$R\aversion\x125\n" +
	"\x10fixed_node_count\x18\x02 \x01(\x03B\t\xbaH\x06\"\x04\x18d(\x00H\x00R\x0efixedNodeCount\x12L\n" +
	"\vautoscaling\x18\x05 \x01(\v2(.nebius.mk8s.v1.NodeGroupAutoscalingSpecH\x00R\vautoscaling\x12@\n" +
	"\btemplate\x18\x03 \x01(\v2\x1c.nebius.mk8s.v1.NodeTemplateB\x06\xbaH\x03\xc8\x01\x01R\btemplate\x12G\n" +
	"\bstrategy\x18\x04 \x01(\v2+.nebius.mk8s.v1.NodeGroupDeploymentStrategyR\bstrategyB\r\n" +
	"\x04size\x12\x05\xbaH\x02\b\x01\"\xf6\x05\n" +
	"\fNodeTemplate\x12@\n" +
	"\bmetadata\x18\x01 \x01(\v2$.nebius.mk8s.v1.NodeMetadataTemplateR\bmetadata\x12;\n" +
	"\x06taints\x18\x02 \x03(\v2\x19.nebius.mk8s.v1.NodeTaintB\b\xbaH\x05\x92\x01\x02\x10dR\x06taints\x12C\n" +
	"\tresources\x18\x03 \x01(\v2\x1d.nebius.mk8s.v1.ResourcesSpecB\x06\xbaH\x03\xc8\x01\x01R\tresources\x12;\n" +
	"\tboot_disk\x18\t \x01(\v2\x18.nebius.mk8s.v1.DiskSpecB\x04\xbaJ\x01\aR\bbootDisk\x12>\n" +
	"\fgpu_settings\x18\r \x01(\v2\x1b.nebius.mk8s.v1.GpuSettingsR\vgpuSettings\x12\x0e\n" +
	"\x02os\x18\x10 \x01(\tR\x02os\x12?\n" +
	"\vgpu_cluster\x18\x04 \x01(\v2\x1e.nebius.mk8s.v1.GpuClusterSpecR\n" +
	"gpuCluster\x12]\n" +
	"\x12network_interfaces\x18\x05 \x03(\v2(.nebius.mk8s.v1.NetworkInterfaceTemplateB\x04\xbaJ\x01\aR\x11networkInterfaces\x12H\n" +
	"\vfilesystems\x18\a \x03(\v2&.nebius.mk8s.v1.AttachedFilesystemSpecR\vfilesystems\x124\n" +
	"\x14cloud_init_user_data\x18\x06 \x01(\tB\x03\xc0J\x01R\x11cloudInitUserData\x12,\n" +
	"\x12service_account_id\x18\n" +
	" \x01(\tR\x10serviceAccountId\x12G\n" +
	"\vpreemptible\x18\x0f \x01(\v2\x1f.nebius.mk8s.v1.PreemptibleSpecB\x04\xbaJ\x01\x06R\vpreemptible\"\xa5\x01\n" +
	"\x14NodeMetadataTemplate\x12R\n" +
	"\x06labels\x18\x01 \x03(\v20.nebius.mk8s.v1.NodeMetadataTemplate.LabelsEntryB\b\xbaH\x05\x9a\x01\x02\x10dR\x06labels\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"<\n" +
	"\vGpuSettings\x12-\n" +
	"\x0edrivers_preset\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\rdriversPreset\" \n" +
	"\x0eGpuClusterSpec\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"\x90\x01\n" +
	"\x18NetworkInterfaceTemplate\x12Q\n" +
	"\x11public_ip_address\x18\x01 \x01(\v2\x1f.nebius.mk8s.v1.PublicIPAddressB\x04\xbaJ\x01\x06R\x0fpublicIpAddress\x12!\n" +
	"\tsubnet_id\x18\x03 \x01(\tB\x04\xbaJ\x01\aR\bsubnetId\"\x11\n" +
	"\x0fPublicIPAddress\"\xbd\x02\n" +
	"\x16AttachedFilesystemSpec\x12Z\n" +
	"\vattach_mode\x18\x01 \x01(\x0e21.nebius.mk8s.v1.AttachedFilesystemSpec.AttachModeB\x06\xbaH\x03\xc8\x01\x01R\n" +
	"attachMode\x12#\n" +
	"\tmount_tag\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\bmountTag\x12U\n" +
	"\x13existing_filesystem\x18\x03 \x01(\v2\".nebius.mk8s.v1.ExistingFilesystemH\x00R\x12existingFilesystem\"<\n" +
	"\n" +
	"AttachMode\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\r\n" +
	"\tREAD_ONLY\x10\x01\x12\x0e\n" +
	"\n" +
	"READ_WRITE\x10\x02B\r\n" +
	"\x04type\x12\x05\xbaH\x02\b\x01\",\n" +
	"\x12ExistingFilesystem\x12\x16\n" +
	"\x02id\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x02id\"\x8f\x02\n" +
	"\x18NodeGroupAutoscalingSpec\x12/\n" +
	"\x0emin_node_count\x18\x01 \x01(\x03B\t\xbaH\x06\"\x04\x18d(\x00R\fminNodeCount\x12/\n" +
	"\x0emax_node_count\x18\x02 \x01(\x03B\t\xbaH\x06\"\x04\x18d(\x00R\fmaxNodeCount:\x90\x01\xbaH\x8c\x01\x1a\x89\x01\n" +
	"!autoscaling.protovalidate.message\x128min_node_count must be less or equal than max_node_count\x1a*this.min_node_count <= this.max_node_count\"\xe0\x01\n" +
	"\tNodeTaint\x12\x18\n" +
	"\x03key\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x03key\x12\x1c\n" +
	"\x05value\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x05value\x12@\n" +
	"\x06effect\x18\x03 \x01(\x0e2 .nebius.mk8s.v1.NodeTaint.EffectB\x06\xbaH\x03\xc8\x01\x01R\x06effect\"Y\n" +
	"\x06Effect\x12\x16\n" +
	"\x12EFFECT_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"NO_EXECUTE\x10\x01\x12\x0f\n" +
	"\vNO_SCHEDULE\x10\x02\x12\x16\n" +
	"\x12PREFER_NO_SCHEDULE\x10\x03\"\xed\x01\n" +
	"\x1bNodeGroupDeploymentStrategy\x12G\n" +
	"\x0fmax_unavailable\x18\x01 \x01(\v2\x1e.nebius.mk8s.v1.PercentOrCountR\x0emaxUnavailable\x12;\n" +
	"\tmax_surge\x18\x02 \x01(\v2\x1e.nebius.mk8s.v1.PercentOrCountR\bmaxSurge\x12H\n" +
	"\rdrain_timeout\x18\x03 \x01(\v2\x19.google.protobuf.DurationB\b\xbaH\x05\xaa\x01\x022\x00R\fdrainTimeout\"h\n" +
	"\x0ePercentOrCount\x12%\n" +
	"\apercent\x18\x01 \x01(\x03B\t\xbaH\x06\"\x04\x18d(\x00H\x00R\apercent\x12\x1f\n" +
	"\x05count\x18\x02 \x01(\x03B\a\xbaH\x04\"\x02(\x00H\x00R\x05countB\x0e\n" +
	"\x05value\x12\x05\xbaH\x02\b\x01\"\x11\n" +
	"\x0fPreemptibleSpec\"\xca\x04\n" +
	"\x0fNodeGroupStatus\x12;\n" +
	"\x05state\x18\x01 \x01(\x0e2%.nebius.mk8s.v1.NodeGroupStatus.StateR\x05state\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12*\n" +
	"\x11target_node_count\x18\x03 \x01(\x03R\x0ftargetNodeCount\x12\x1d\n" +
	"\n" +
	"node_count\x18\x04 \x01(\x03R\tnodeCount\x12.\n" +
	"\x13outdated_node_count\x18\x05 \x01(\x03R\x11outdatedNodeCount\x12(\n" +
	"\x10ready_node_count\x18\x06 \x01(\x03R\x0ereadyNodeCount\x12\x89\x01\n" +
	"\n" +
	"conditions\x182 \x03(\v2\x19.nebius.mk8s.v1.ConditionBN\xd2JI\n" +
	"\n" +
	"2025-08-01\x12;it is not implemented well, messages should be used instead\x18\x01R\n" +
	"conditions\x12@\n" +
	"\x06events\x18= \x03(\v2(.nebius.common.v1.RecurrentResourceEventR\x06events\x12 \n" +
	"\vreconciling\x18d \x01(\bR\vreconciling\"K\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fPROVISIONING\x10\x01\x12\v\n" +
	"\aRUNNING\x10\x02\x12\f\n" +
	"\bDELETING\x10\x03BW\n" +
	"\x15ai.nebius.pub.mk8s.v1B\x0eNodeGroupProtoP\x01Z,github.com/nebius/gosdk/proto/nebius/mk8s/v1b\x06proto3"

var (
	file_nebius_mk8s_v1_node_group_proto_rawDescOnce sync.Once
	file_nebius_mk8s_v1_node_group_proto_rawDescData []byte
)

func file_nebius_mk8s_v1_node_group_proto_rawDescGZIP() []byte {
	file_nebius_mk8s_v1_node_group_proto_rawDescOnce.Do(func() {
		file_nebius_mk8s_v1_node_group_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_nebius_mk8s_v1_node_group_proto_rawDesc), len(file_nebius_mk8s_v1_node_group_proto_rawDesc)))
	})
	return file_nebius_mk8s_v1_node_group_proto_rawDescData
}

var file_nebius_mk8s_v1_node_group_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_nebius_mk8s_v1_node_group_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_nebius_mk8s_v1_node_group_proto_goTypes = []any{
	(AttachedFilesystemSpec_AttachMode)(0), // 0: nebius.mk8s.v1.AttachedFilesystemSpec.AttachMode
	(NodeTaint_Effect)(0),                  // 1: nebius.mk8s.v1.NodeTaint.Effect
	(NodeGroupStatus_State)(0),             // 2: nebius.mk8s.v1.NodeGroupStatus.State
	(*NodeGroup)(nil),                      // 3: nebius.mk8s.v1.NodeGroup
	(*NodeGroupSpec)(nil),                  // 4: nebius.mk8s.v1.NodeGroupSpec
	(*NodeTemplate)(nil),                   // 5: nebius.mk8s.v1.NodeTemplate
	(*NodeMetadataTemplate)(nil),           // 6: nebius.mk8s.v1.NodeMetadataTemplate
	(*GpuSettings)(nil),                    // 7: nebius.mk8s.v1.GpuSettings
	(*GpuClusterSpec)(nil),                 // 8: nebius.mk8s.v1.GpuClusterSpec
	(*NetworkInterfaceTemplate)(nil),       // 9: nebius.mk8s.v1.NetworkInterfaceTemplate
	(*PublicIPAddress)(nil),                // 10: nebius.mk8s.v1.PublicIPAddress
	(*AttachedFilesystemSpec)(nil),         // 11: nebius.mk8s.v1.AttachedFilesystemSpec
	(*ExistingFilesystem)(nil),             // 12: nebius.mk8s.v1.ExistingFilesystem
	(*NodeGroupAutoscalingSpec)(nil),       // 13: nebius.mk8s.v1.NodeGroupAutoscalingSpec
	(*NodeTaint)(nil),                      // 14: nebius.mk8s.v1.NodeTaint
	(*NodeGroupDeploymentStrategy)(nil),    // 15: nebius.mk8s.v1.NodeGroupDeploymentStrategy
	(*PercentOrCount)(nil),                 // 16: nebius.mk8s.v1.PercentOrCount
	(*PreemptibleSpec)(nil),                // 17: nebius.mk8s.v1.PreemptibleSpec
	(*NodeGroupStatus)(nil),                // 18: nebius.mk8s.v1.NodeGroupStatus
	nil,                                    // 19: nebius.mk8s.v1.NodeMetadataTemplate.LabelsEntry
	(*v1.ResourceMetadata)(nil),            // 20: nebius.common.v1.ResourceMetadata
	(*ResourcesSpec)(nil),                  // 21: nebius.mk8s.v1.ResourcesSpec
	(*DiskSpec)(nil),                       // 22: nebius.mk8s.v1.DiskSpec
	(*durationpb.Duration)(nil),            // 23: google.protobuf.Duration
	(*Condition)(nil),                      // 24: nebius.mk8s.v1.Condition
	(*v1.RecurrentResourceEvent)(nil),      // 25: nebius.common.v1.RecurrentResourceEvent
}
var file_nebius_mk8s_v1_node_group_proto_depIdxs = []int32{
	20, // 0: nebius.mk8s.v1.NodeGroup.metadata:type_name -> nebius.common.v1.ResourceMetadata
	4,  // 1: nebius.mk8s.v1.NodeGroup.spec:type_name -> nebius.mk8s.v1.NodeGroupSpec
	18, // 2: nebius.mk8s.v1.NodeGroup.status:type_name -> nebius.mk8s.v1.NodeGroupStatus
	13, // 3: nebius.mk8s.v1.NodeGroupSpec.autoscaling:type_name -> nebius.mk8s.v1.NodeGroupAutoscalingSpec
	5,  // 4: nebius.mk8s.v1.NodeGroupSpec.template:type_name -> nebius.mk8s.v1.NodeTemplate
	15, // 5: nebius.mk8s.v1.NodeGroupSpec.strategy:type_name -> nebius.mk8s.v1.NodeGroupDeploymentStrategy
	6,  // 6: nebius.mk8s.v1.NodeTemplate.metadata:type_name -> nebius.mk8s.v1.NodeMetadataTemplate
	14, // 7: nebius.mk8s.v1.NodeTemplate.taints:type_name -> nebius.mk8s.v1.NodeTaint
	21, // 8: nebius.mk8s.v1.NodeTemplate.resources:type_name -> nebius.mk8s.v1.ResourcesSpec
	22, // 9: nebius.mk8s.v1.NodeTemplate.boot_disk:type_name -> nebius.mk8s.v1.DiskSpec
	7,  // 10: nebius.mk8s.v1.NodeTemplate.gpu_settings:type_name -> nebius.mk8s.v1.GpuSettings
	8,  // 11: nebius.mk8s.v1.NodeTemplate.gpu_cluster:type_name -> nebius.mk8s.v1.GpuClusterSpec
	9,  // 12: nebius.mk8s.v1.NodeTemplate.network_interfaces:type_name -> nebius.mk8s.v1.NetworkInterfaceTemplate
	11, // 13: nebius.mk8s.v1.NodeTemplate.filesystems:type_name -> nebius.mk8s.v1.AttachedFilesystemSpec
	17, // 14: nebius.mk8s.v1.NodeTemplate.preemptible:type_name -> nebius.mk8s.v1.PreemptibleSpec
	19, // 15: nebius.mk8s.v1.NodeMetadataTemplate.labels:type_name -> nebius.mk8s.v1.NodeMetadataTemplate.LabelsEntry
	10, // 16: nebius.mk8s.v1.NetworkInterfaceTemplate.public_ip_address:type_name -> nebius.mk8s.v1.PublicIPAddress
	0,  // 17: nebius.mk8s.v1.AttachedFilesystemSpec.attach_mode:type_name -> nebius.mk8s.v1.AttachedFilesystemSpec.AttachMode
	12, // 18: nebius.mk8s.v1.AttachedFilesystemSpec.existing_filesystem:type_name -> nebius.mk8s.v1.ExistingFilesystem
	1,  // 19: nebius.mk8s.v1.NodeTaint.effect:type_name -> nebius.mk8s.v1.NodeTaint.Effect
	16, // 20: nebius.mk8s.v1.NodeGroupDeploymentStrategy.max_unavailable:type_name -> nebius.mk8s.v1.PercentOrCount
	16, // 21: nebius.mk8s.v1.NodeGroupDeploymentStrategy.max_surge:type_name -> nebius.mk8s.v1.PercentOrCount
	23, // 22: nebius.mk8s.v1.NodeGroupDeploymentStrategy.drain_timeout:type_name -> google.protobuf.Duration
	2,  // 23: nebius.mk8s.v1.NodeGroupStatus.state:type_name -> nebius.mk8s.v1.NodeGroupStatus.State
	24, // 24: nebius.mk8s.v1.NodeGroupStatus.conditions:type_name -> nebius.mk8s.v1.Condition
	25, // 25: nebius.mk8s.v1.NodeGroupStatus.events:type_name -> nebius.common.v1.RecurrentResourceEvent
	26, // [26:26] is the sub-list for method output_type
	26, // [26:26] is the sub-list for method input_type
	26, // [26:26] is the sub-list for extension type_name
	26, // [26:26] is the sub-list for extension extendee
	0,  // [0:26] is the sub-list for field type_name
}

func init() { file_nebius_mk8s_v1_node_group_proto_init() }
func file_nebius_mk8s_v1_node_group_proto_init() {
	if File_nebius_mk8s_v1_node_group_proto != nil {
		return
	}
	file_nebius_mk8s_v1_instance_template_proto_init()
	file_nebius_mk8s_v1_condition_proto_init()
	file_nebius_mk8s_v1_node_group_proto_msgTypes[1].OneofWrappers = []any{
		(*NodeGroupSpec_FixedNodeCount)(nil),
		(*NodeGroupSpec_Autoscaling)(nil),
	}
	file_nebius_mk8s_v1_node_group_proto_msgTypes[8].OneofWrappers = []any{
		(*AttachedFilesystemSpec_ExistingFilesystem)(nil),
	}
	file_nebius_mk8s_v1_node_group_proto_msgTypes[13].OneofWrappers = []any{
		(*PercentOrCount_Percent)(nil),
		(*PercentOrCount_Count)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_nebius_mk8s_v1_node_group_proto_rawDesc), len(file_nebius_mk8s_v1_node_group_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_nebius_mk8s_v1_node_group_proto_goTypes,
		DependencyIndexes: file_nebius_mk8s_v1_node_group_proto_depIdxs,
		EnumInfos:         file_nebius_mk8s_v1_node_group_proto_enumTypes,
		MessageInfos:      file_nebius_mk8s_v1_node_group_proto_msgTypes,
	}.Build()
	File_nebius_mk8s_v1_node_group_proto = out.File
	file_nebius_mk8s_v1_node_group_proto_goTypes = nil
	file_nebius_mk8s_v1_node_group_proto_depIdxs = nil
}

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.28.3
// source: nebius/mk8s/v1alpha1/node_group.proto

package v1alpha1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	_ "github.com/nebius/gosdk/proto/nebius"
	v1 "github.com/nebius/gosdk/proto/nebius/common/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type AttachedFilesystemSpec_AttachMode int32

const (
	AttachedFilesystemSpec_UNSPECIFIED AttachedFilesystemSpec_AttachMode = 0
	AttachedFilesystemSpec_READ_ONLY   AttachedFilesystemSpec_AttachMode = 1
	AttachedFilesystemSpec_READ_WRITE  AttachedFilesystemSpec_AttachMode = 2
)

// Enum value maps for AttachedFilesystemSpec_AttachMode.
var (
	AttachedFilesystemSpec_AttachMode_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "READ_ONLY",
		2: "READ_WRITE",
	}
	AttachedFilesystemSpec_AttachMode_value = map[string]int32{
		"UNSPECIFIED": 0,
		"READ_ONLY":   1,
		"READ_WRITE":  2,
	}
)

func (x AttachedFilesystemSpec_AttachMode) Enum() *AttachedFilesystemSpec_AttachMode {
	p := new(AttachedFilesystemSpec_AttachMode)
	*p = x
	return p
}

func (x AttachedFilesystemSpec_AttachMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AttachedFilesystemSpec_AttachMode) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_mk8s_v1alpha1_node_group_proto_enumTypes[0].Descriptor()
}

func (AttachedFilesystemSpec_AttachMode) Type() protoreflect.EnumType {
	return &file_nebius_mk8s_v1alpha1_node_group_proto_enumTypes[0]
}

func (x AttachedFilesystemSpec_AttachMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AttachedFilesystemSpec_AttachMode.Descriptor instead.
func (AttachedFilesystemSpec_AttachMode) EnumDescriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{8, 0}
}

type NodeTaint_Effect int32

const (
	NodeTaint_EFFECT_UNSPECIFIED NodeTaint_Effect = 0
	NodeTaint_NO_EXECUTE         NodeTaint_Effect = 1
	NodeTaint_NO_SCHEDULE        NodeTaint_Effect = 2
	NodeTaint_PREFER_NO_SCHEDULE NodeTaint_Effect = 3
)

// Enum value maps for NodeTaint_Effect.
var (
	NodeTaint_Effect_name = map[int32]string{
		0: "EFFECT_UNSPECIFIED",
		1: "NO_EXECUTE",
		2: "NO_SCHEDULE",
		3: "PREFER_NO_SCHEDULE",
	}
	NodeTaint_Effect_value = map[string]int32{
		"EFFECT_UNSPECIFIED": 0,
		"NO_EXECUTE":         1,
		"NO_SCHEDULE":        2,
		"PREFER_NO_SCHEDULE": 3,
	}
)

func (x NodeTaint_Effect) Enum() *NodeTaint_Effect {
	p := new(NodeTaint_Effect)
	*p = x
	return p
}

func (x NodeTaint_Effect) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeTaint_Effect) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_mk8s_v1alpha1_node_group_proto_enumTypes[1].Descriptor()
}

func (NodeTaint_Effect) Type() protoreflect.EnumType {
	return &file_nebius_mk8s_v1alpha1_node_group_proto_enumTypes[1]
}

func (x NodeTaint_Effect) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeTaint_Effect.Descriptor instead.
func (NodeTaint_Effect) EnumDescriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{12, 0}
}

type NodeGroupStatus_State int32

const (
	NodeGroupStatus_STATE_UNSPECIFIED NodeGroupStatus_State = 0
	NodeGroupStatus_PROVISIONING      NodeGroupStatus_State = 1
	NodeGroupStatus_RUNNING           NodeGroupStatus_State = 2
	NodeGroupStatus_DELETING          NodeGroupStatus_State = 3
)

// Enum value maps for NodeGroupStatus_State.
var (
	NodeGroupStatus_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "PROVISIONING",
		2: "RUNNING",
		3: "DELETING",
	}
	NodeGroupStatus_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"PROVISIONING":      1,
		"RUNNING":           2,
		"DELETING":          3,
	}
)

func (x NodeGroupStatus_State) Enum() *NodeGroupStatus_State {
	p := new(NodeGroupStatus_State)
	*p = x
	return p
}

func (x NodeGroupStatus_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (NodeGroupStatus_State) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_mk8s_v1alpha1_node_group_proto_enumTypes[2].Descriptor()
}

func (NodeGroupStatus_State) Type() protoreflect.EnumType {
	return &file_nebius_mk8s_v1alpha1_node_group_proto_enumTypes[2]
}

func (x NodeGroupStatus_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use NodeGroupStatus_State.Descriptor instead.
func (NodeGroupStatus_State) EnumDescriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{15, 0}
}

// NodeGroup represents Kubernetes node pool
type NodeGroup struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Metadata      *v1.ResourceMetadata   `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"` // the parent_id is an ID of Cluster
	Spec          *NodeGroupSpec         `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	Status        *NodeGroupStatus       `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGroup) Reset() {
	*x = NodeGroup{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGroup) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGroup) ProtoMessage() {}

func (x *NodeGroup) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGroup.ProtoReflect.Descriptor instead.
func (*NodeGroup) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{0}
}

func (x *NodeGroup) GetMetadata() *v1.ResourceMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *NodeGroup) GetSpec() *NodeGroupSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *NodeGroup) GetStatus() *NodeGroupStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type NodeGroupSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Version is desired Kubernetes version of the cluster. For now only acceptable format is
	// `MAJOR.MINOR` like "1.31". Option for patch version update will be added later.
	// By default the cluster control plane MAJOR.MINOR version will be used.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// Types that are valid to be assigned to Size:
	//
	//	*NodeGroupSpec_FixedNodeCount
	//	*NodeGroupSpec_Autoscaling
	Size          isNodeGroupSpec_Size         `protobuf_oneof:"size"`
	Template      *NodeTemplate                `protobuf:"bytes,3,opt,name=template,proto3" json:"template,omitempty"`
	Strategy      *NodeGroupDeploymentStrategy `protobuf:"bytes,4,opt,name=strategy,proto3" json:"strategy,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGroupSpec) Reset() {
	*x = NodeGroupSpec{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGroupSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGroupSpec) ProtoMessage() {}

func (x *NodeGroupSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGroupSpec.ProtoReflect.Descriptor instead.
func (*NodeGroupSpec) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{1}
}

func (x *NodeGroupSpec) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *NodeGroupSpec) GetSize() isNodeGroupSpec_Size {
	if x != nil {
		return x.Size
	}
	return nil
}

func (x *NodeGroupSpec) GetFixedNodeCount() int64 {
	if x != nil {
		if x, ok := x.Size.(*NodeGroupSpec_FixedNodeCount); ok {
			return x.FixedNodeCount
		}
	}
	return 0
}

func (x *NodeGroupSpec) GetAutoscaling() *NodeGroupAutoscalingSpec {
	if x != nil {
		if x, ok := x.Size.(*NodeGroupSpec_Autoscaling); ok {
			return x.Autoscaling
		}
	}
	return nil
}

func (x *NodeGroupSpec) GetTemplate() *NodeTemplate {
	if x != nil {
		return x.Template
	}
	return nil
}

func (x *NodeGroupSpec) GetStrategy() *NodeGroupDeploymentStrategy {
	if x != nil {
		return x.Strategy
	}
	return nil
}

type isNodeGroupSpec_Size interface {
	isNodeGroupSpec_Size()
}

type NodeGroupSpec_FixedNodeCount struct {
	FixedNodeCount int64 `protobuf:"varint,2,opt,name=fixed_node_count,json=fixedNodeCount,proto3,oneof"`
}

type NodeGroupSpec_Autoscaling struct {
	Autoscaling *NodeGroupAutoscalingSpec `protobuf:"bytes,5,opt,name=autoscaling,proto3,oneof"`
}

func (*NodeGroupSpec_FixedNodeCount) isNodeGroupSpec_Size() {}

func (*NodeGroupSpec_Autoscaling) isNodeGroupSpec_Size() {}

type NodeTemplate struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Metadata  *NodeMetadataTemplate  `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Taints    []*NodeTaint           `protobuf:"bytes,2,rep,name=taints,proto3" json:"taints,omitempty"`
	Resources *ResourcesSpec         `protobuf:"bytes,3,opt,name=resources,proto3" json:"resources,omitempty"`
	BootDisk  *DiskSpec              `protobuf:"bytes,9,opt,name=boot_disk,json=bootDisk,proto3" json:"boot_disk,omitempty"`
	// GPU-related settings.
	GpuSettings       *GpuSettings                `protobuf:"bytes,13,opt,name=gpu_settings,json=gpuSettings,proto3" json:"gpu_settings,omitempty"`
	GpuCluster        *GpuClusterSpec             `protobuf:"bytes,4,opt,name=gpu_cluster,json=gpuCluster,proto3" json:"gpu_cluster,omitempty"`
	NetworkInterfaces []*NetworkInterfaceTemplate `protobuf:"bytes,5,rep,name=network_interfaces,json=networkInterfaces,proto3" json:"network_interfaces,omitempty"`
	Filesystems       []*AttachedFilesystemSpec   `protobuf:"bytes,7,rep,name=filesystems,proto3" json:"filesystems,omitempty"`
	// cloud-init user-data. Must contain at least one SSH key.
	CloudInitUserData string `protobuf:"bytes,6,opt,name=cloud_init_user_data,json=cloudInitUserData,proto3" json:"cloud_init_user_data,omitempty"`
	// the Nebius service account whose credentials will be available on the nodes of the group.
	// With these credentials, it is possible to make `nebius` CLI or public API requests from the nodes without the need for extra authentication.
	// This service account is also used to make requests to container registry.
	//
	// `resource.serviceaccount.issueAccessToken` permission is required to use this field.
	ServiceAccountId string `protobuf:"bytes,10,opt,name=service_account_id,json=serviceAccountId,proto3" json:"service_account_id,omitempty"`
	// Configures whether the nodes in the group are preemptible.
	// Set to empty value to enable preemptible nodes.
	Preemptible   *PreemptibleSpec `protobuf:"bytes,15,opt,name=preemptible,proto3" json:"preemptible,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeTemplate) Reset() {
	*x = NodeTemplate{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeTemplate) ProtoMessage() {}

func (x *NodeTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeTemplate.ProtoReflect.Descriptor instead.
func (*NodeTemplate) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{2}
}

func (x *NodeTemplate) GetMetadata() *NodeMetadataTemplate {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *NodeTemplate) GetTaints() []*NodeTaint {
	if x != nil {
		return x.Taints
	}
	return nil
}

func (x *NodeTemplate) GetResources() *ResourcesSpec {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *NodeTemplate) GetBootDisk() *DiskSpec {
	if x != nil {
		return x.BootDisk
	}
	return nil
}

func (x *NodeTemplate) GetGpuSettings() *GpuSettings {
	if x != nil {
		return x.GpuSettings
	}
	return nil
}

func (x *NodeTemplate) GetGpuCluster() *GpuClusterSpec {
	if x != nil {
		return x.GpuCluster
	}
	return nil
}

func (x *NodeTemplate) GetNetworkInterfaces() []*NetworkInterfaceTemplate {
	if x != nil {
		return x.NetworkInterfaces
	}
	return nil
}

func (x *NodeTemplate) GetFilesystems() []*AttachedFilesystemSpec {
	if x != nil {
		return x.Filesystems
	}
	return nil
}

func (x *NodeTemplate) GetCloudInitUserData() string {
	if x != nil {
		return x.CloudInitUserData
	}
	return ""
}

func (x *NodeTemplate) GetServiceAccountId() string {
	if x != nil {
		return x.ServiceAccountId
	}
	return ""
}

func (x *NodeTemplate) GetPreemptible() *PreemptibleSpec {
	if x != nil {
		return x.Preemptible
	}
	return nil
}

type NodeMetadataTemplate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Labels will be propagated into nodes metadata.
	// System labels containing "kubernetes.io" and "k8s.io" will not be propagated.
	// On update labels they will not be updated in nodes right away, only on node group update.
	Labels        map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeMetadataTemplate) Reset() {
	*x = NodeMetadataTemplate{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeMetadataTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeMetadataTemplate) ProtoMessage() {}

func (x *NodeMetadataTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeMetadataTemplate.ProtoReflect.Descriptor instead.
func (*NodeMetadataTemplate) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{3}
}

func (x *NodeMetadataTemplate) GetLabels() map[string]string {
	if x != nil {
		return x.Labels
	}
	return nil
}

// GPU-related settings.
type GpuSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Identifier of the predefined set of drivers included in the ComputeImage deployed on ComputeInstances that are part of the NodeGroup.
	// Supported presets for different platform / k8s version combinations:
	//
	//	gpu-l40s-a, gpu-l40s-d, gpu-h100-sxm, gpu-h200-sxm:
	//	  k8s: 1.30 → "cuda12" (CUDA 12.4)
	//	  k8s: 1.31 → "cuda12" (CUDA 12.4), "cuda12.4", "cuda12.8"
	//	gpu-b200-sxm:
	//	  k8s: 1.31 → "cuda12" (CUDA 12.8), "cuda12.8"
	DriversPreset string `protobuf:"bytes,1,opt,name=drivers_preset,json=driversPreset,proto3" json:"drivers_preset,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GpuSettings) Reset() {
	*x = GpuSettings{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GpuSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GpuSettings) ProtoMessage() {}

func (x *GpuSettings) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GpuSettings.ProtoReflect.Descriptor instead.
func (*GpuSettings) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{4}
}

func (x *GpuSettings) GetDriversPreset() string {
	if x != nil {
		return x.DriversPreset
	}
	return ""
}

type GpuClusterSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GpuClusterSpec) Reset() {
	*x = GpuClusterSpec{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GpuClusterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GpuClusterSpec) ProtoMessage() {}

func (x *GpuClusterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GpuClusterSpec.ProtoReflect.Descriptor instead.
func (*GpuClusterSpec) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{5}
}

func (x *GpuClusterSpec) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type NetworkInterfaceTemplate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Public IPv4 address associated with the interface.
	PublicIpAddress *PublicIPAddress `protobuf:"bytes,1,opt,name=public_ip_address,json=publicIpAddress,proto3" json:"public_ip_address,omitempty"`
	// Subnet ID that will be attached to a node cloud intstance network interface.
	// By default control plane subnet_id used.
	// Subnet should be located in the same network with control plane and have same parent ID as cluster.
	SubnetId      string `protobuf:"bytes,3,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NetworkInterfaceTemplate) Reset() {
	*x = NetworkInterfaceTemplate{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NetworkInterfaceTemplate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NetworkInterfaceTemplate) ProtoMessage() {}

func (x *NetworkInterfaceTemplate) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NetworkInterfaceTemplate.ProtoReflect.Descriptor instead.
func (*NetworkInterfaceTemplate) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{6}
}

func (x *NetworkInterfaceTemplate) GetPublicIpAddress() *PublicIPAddress {
	if x != nil {
		return x.PublicIpAddress
	}
	return nil
}

func (x *NetworkInterfaceTemplate) GetSubnetId() string {
	if x != nil {
		return x.SubnetId
	}
	return ""
}

// Describes a public IP address.
type PublicIPAddress struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PublicIPAddress) Reset() {
	*x = PublicIPAddress{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PublicIPAddress) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PublicIPAddress) ProtoMessage() {}

func (x *PublicIPAddress) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PublicIPAddress.ProtoReflect.Descriptor instead.
func (*PublicIPAddress) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{7}
}

type AttachedFilesystemSpec struct {
	state      protoimpl.MessageState            `protogen:"open.v1"`
	AttachMode AttachedFilesystemSpec_AttachMode `protobuf:"varint,1,opt,name=attach_mode,json=attachMode,proto3,enum=nebius.mk8s.v1alpha1.AttachedFilesystemSpec_AttachMode" json:"attach_mode,omitempty"`
	DeviceName string                            `protobuf:"bytes,2,opt,name=device_name,json=deviceName,proto3" json:"device_name,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*AttachedFilesystemSpec_ExistingFilesystem
	Type          isAttachedFilesystemSpec_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttachedFilesystemSpec) Reset() {
	*x = AttachedFilesystemSpec{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttachedFilesystemSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachedFilesystemSpec) ProtoMessage() {}

func (x *AttachedFilesystemSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachedFilesystemSpec.ProtoReflect.Descriptor instead.
func (*AttachedFilesystemSpec) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{8}
}

func (x *AttachedFilesystemSpec) GetAttachMode() AttachedFilesystemSpec_AttachMode {
	if x != nil {
		return x.AttachMode
	}
	return AttachedFilesystemSpec_UNSPECIFIED
}

func (x *AttachedFilesystemSpec) GetDeviceName() string {
	if x != nil {
		return x.DeviceName
	}
	return ""
}

func (x *AttachedFilesystemSpec) GetType() isAttachedFilesystemSpec_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *AttachedFilesystemSpec) GetExistingFilesystem() *ExistingFilesystem {
	if x != nil {
		if x, ok := x.Type.(*AttachedFilesystemSpec_ExistingFilesystem); ok {
			return x.ExistingFilesystem
		}
	}
	return nil
}

type isAttachedFilesystemSpec_Type interface {
	isAttachedFilesystemSpec_Type()
}

type AttachedFilesystemSpec_ExistingFilesystem struct {
	ExistingFilesystem *ExistingFilesystem `protobuf:"bytes,3,opt,name=existing_filesystem,json=existingFilesystem,proto3,oneof"`
}

func (*AttachedFilesystemSpec_ExistingFilesystem) isAttachedFilesystemSpec_Type() {}

type ExistingFilesystem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExistingFilesystem) Reset() {
	*x = ExistingFilesystem{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExistingFilesystem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExistingFilesystem) ProtoMessage() {}

func (x *ExistingFilesystem) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExistingFilesystem.ProtoReflect.Descriptor instead.
func (*ExistingFilesystem) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{9}
}

func (x *ExistingFilesystem) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type NodeGroupAutoscalingSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MinNodeCount  int64                  `protobuf:"varint,1,opt,name=min_node_count,json=minNodeCount,proto3" json:"min_node_count,omitempty"`
	MaxNodeCount  int64                  `protobuf:"varint,2,opt,name=max_node_count,json=maxNodeCount,proto3" json:"max_node_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGroupAutoscalingSpec) Reset() {
	*x = NodeGroupAutoscalingSpec{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGroupAutoscalingSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGroupAutoscalingSpec) ProtoMessage() {}

func (x *NodeGroupAutoscalingSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGroupAutoscalingSpec.ProtoReflect.Descriptor instead.
func (*NodeGroupAutoscalingSpec) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{10}
}

func (x *NodeGroupAutoscalingSpec) GetMinNodeCount() int64 {
	if x != nil {
		return x.MinNodeCount
	}
	return 0
}

func (x *NodeGroupAutoscalingSpec) GetMaxNodeCount() int64 {
	if x != nil {
		return x.MaxNodeCount
	}
	return 0
}

type PreemptibleSpec struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PreemptibleSpec) Reset() {
	*x = PreemptibleSpec{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PreemptibleSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreemptibleSpec) ProtoMessage() {}

func (x *PreemptibleSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreemptibleSpec.ProtoReflect.Descriptor instead.
func (*PreemptibleSpec) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{11}
}

// See https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
type NodeTaint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           string                 `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Effect        NodeTaint_Effect       `protobuf:"varint,3,opt,name=effect,proto3,enum=nebius.mk8s.v1alpha1.NodeTaint_Effect" json:"effect,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeTaint) Reset() {
	*x = NodeTaint{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeTaint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeTaint) ProtoMessage() {}

func (x *NodeTaint) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeTaint.ProtoReflect.Descriptor instead.
func (*NodeTaint) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{12}
}

func (x *NodeTaint) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *NodeTaint) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

func (x *NodeTaint) GetEffect() NodeTaint_Effect {
	if x != nil {
		return x.Effect
	}
	return NodeTaint_EFFECT_UNSPECIFIED
}

type NodeGroupDeploymentStrategy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The maximum number of machines that can be unavailable during the update.
	// Value can be an absolute number (ex: 5) or a percentage of desired
	// machines (ex: 10%).
	// Absolute number is calculated from percentage by rounding down.
	// This can not be 0 if MaxSurge is 0.
	// Defaults to 0.
	// Example: when this is set to 30%, the old MachineSet can be scaled
	// down to 70% of desired machines immediately when the rolling update
	// starts. Once new machines are ready, old MachineSet can be scaled
	// down further, followed by scaling up the new MachineSet, ensuring
	// that the total number of machines available at all times
	// during the update is at least 70% of desired machines.
	MaxUnavailable *PercentOrCount `protobuf:"bytes,1,opt,name=max_unavailable,json=maxUnavailable,proto3" json:"max_unavailable,omitempty"`
	// The maximum number of machines that can be scheduled above the
	// desired number of machines.
	// Value can be an absolute number (ex: 5) or a percentage of
	// desired machines (ex: 10%).
	// This can not be 0 if MaxUnavailable is 0.
	// Absolute number is calculated from percentage by rounding up.
	// Defaults to 1.
	// Example: when this is set to 30%, the new MachineSet can be scaled
	// up immediately when the rolling update starts, such that the total
	// number of old and new machines do not exceed 130% of desired
	// machines. Once old machines have been killed, new MachineSet can
	// be scaled up further, ensuring that total number of machines running
	// at any time during the update is at most 130% of desired machines.
	MaxSurge *PercentOrCount `protobuf:"bytes,2,opt,name=max_surge,json=maxSurge,proto3" json:"max_surge,omitempty"`
	// DrainTimeout is the total amount of time that the service will spend on draining a node.
	// By default, node can be drained without any time limitations.
	// NOTE: NodeDrainTimeout is different from `kubectl drain --timeout`
	DrainTimeout  *durationpb.Duration `protobuf:"bytes,3,opt,name=drain_timeout,json=drainTimeout,proto3" json:"drain_timeout,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGroupDeploymentStrategy) Reset() {
	*x = NodeGroupDeploymentStrategy{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGroupDeploymentStrategy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGroupDeploymentStrategy) ProtoMessage() {}

func (x *NodeGroupDeploymentStrategy) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGroupDeploymentStrategy.ProtoReflect.Descriptor instead.
func (*NodeGroupDeploymentStrategy) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{13}
}

func (x *NodeGroupDeploymentStrategy) GetMaxUnavailable() *PercentOrCount {
	if x != nil {
		return x.MaxUnavailable
	}
	return nil
}

func (x *NodeGroupDeploymentStrategy) GetMaxSurge() *PercentOrCount {
	if x != nil {
		return x.MaxSurge
	}
	return nil
}

func (x *NodeGroupDeploymentStrategy) GetDrainTimeout() *durationpb.Duration {
	if x != nil {
		return x.DrainTimeout
	}
	return nil
}

type PercentOrCount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Value:
	//
	//	*PercentOrCount_Percent
	//	*PercentOrCount_Count
	Value         isPercentOrCount_Value `protobuf_oneof:"value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PercentOrCount) Reset() {
	*x = PercentOrCount{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PercentOrCount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PercentOrCount) ProtoMessage() {}

func (x *PercentOrCount) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PercentOrCount.ProtoReflect.Descriptor instead.
func (*PercentOrCount) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{14}
}

func (x *PercentOrCount) GetValue() isPercentOrCount_Value {
	if x != nil {
		return x.Value
	}
	return nil
}

func (x *PercentOrCount) GetPercent() int64 {
	if x != nil {
		if x, ok := x.Value.(*PercentOrCount_Percent); ok {
			return x.Percent
		}
	}
	return 0
}

func (x *PercentOrCount) GetCount() int64 {
	if x != nil {
		if x, ok := x.Value.(*PercentOrCount_Count); ok {
			return x.Count
		}
	}
	return 0
}

type isPercentOrCount_Value interface {
	isPercentOrCount_Value()
}

type PercentOrCount_Percent struct {
	Percent int64 `protobuf:"varint,1,opt,name=percent,proto3,oneof"`
}

type PercentOrCount_Count struct {
	Count int64 `protobuf:"varint,2,opt,name=count,proto3,oneof"`
}

func (*PercentOrCount_Percent) isPercentOrCount_Value() {}

func (*PercentOrCount_Count) isPercentOrCount_Value() {}

type NodeGroupStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	State NodeGroupStatus_State  `protobuf:"varint,1,opt,name=state,proto3,enum=nebius.mk8s.v1alpha1.NodeGroupStatus_State" json:"state,omitempty"`
	// Version have format `MAJOR.MINOR.PATCH-nebius-node.n` like "1.30.0-nebius-node.10".
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Desired total number of nodes that should be in the node group.
	// It is either fixed_node_count or arbitrary number between min_node_count and max_node_count decided by autoscaler.
	TargetNodeCount int64 `protobuf:"varint,3,opt,name=target_node_count,json=targetNodeCount,proto3" json:"target_node_count,omitempty"`
	// Total number of nodes that are currently in the node group.
	// Both ready and not ready nodes are counted.
	NodeCount int64 `protobuf:"varint,4,opt,name=node_count,json=nodeCount,proto3" json:"node_count,omitempty"`
	// Total number of nodes that has outdated node configuration.
	// These nodes will be replaced by new nodes with up-to-date configuration.
	OutdatedNodeCount int64 `protobuf:"varint,5,opt,name=outdated_node_count,json=outdatedNodeCount,proto3" json:"outdated_node_count,omitempty"`
	// Total number of nodes that successfully joined the cluster and are ready to serve workloads.
	// Both outdated and up-to-date nodes are counted.
	ReadyNodeCount int64 `protobuf:"varint,6,opt,name=ready_node_count,json=readyNodeCount,proto3" json:"ready_node_count,omitempty"`
	// Deprecated: Marked as deprecated in nebius/mk8s/v1alpha1/node_group.proto.
	Conditions []*Condition `protobuf:"bytes,50,rep,name=conditions,proto3" json:"conditions,omitempty"`
	// Show that changes are in flight
	Reconciling   bool `protobuf:"varint,100,opt,name=reconciling,proto3" json:"reconciling,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NodeGroupStatus) Reset() {
	*x = NodeGroupStatus{}
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NodeGroupStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NodeGroupStatus) ProtoMessage() {}

func (x *NodeGroupStatus) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NodeGroupStatus.ProtoReflect.Descriptor instead.
func (*NodeGroupStatus) Descriptor() ([]byte, []int) {
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP(), []int{15}
}

func (x *NodeGroupStatus) GetState() NodeGroupStatus_State {
	if x != nil {
		return x.State
	}
	return NodeGroupStatus_STATE_UNSPECIFIED
}

func (x *NodeGroupStatus) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *NodeGroupStatus) GetTargetNodeCount() int64 {
	if x != nil {
		return x.TargetNodeCount
	}
	return 0
}

func (x *NodeGroupStatus) GetNodeCount() int64 {
	if x != nil {
		return x.NodeCount
	}
	return 0
}

func (x *NodeGroupStatus) GetOutdatedNodeCount() int64 {
	if x != nil {
		return x.OutdatedNodeCount
	}
	return 0
}

func (x *NodeGroupStatus) GetReadyNodeCount() int64 {
	if x != nil {
		return x.ReadyNodeCount
	}
	return 0
}

// Deprecated: Marked as deprecated in nebius/mk8s/v1alpha1/node_group.proto.
func (x *NodeGroupStatus) GetConditions() []*Condition {
	if x != nil {
		return x.Conditions
	}
	return nil
}

func (x *NodeGroupStatus) GetReconciling() bool {
	if x != nil {
		return x.Reconciling
	}
	return false
}

var File_nebius_mk8s_v1alpha1_node_group_proto protoreflect.FileDescriptor

const file_nebius_mk8s_v1alpha1_node_group_proto_rawDesc = "" +
	"\n" +
	"%nebius/mk8s/v1alpha1/node_group.proto\x12\x14nebius.mk8s.v1alpha1\x1a\x1bbuf/validate/validate.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x18nebius/annotations.proto\x1a\x1fnebius/common/v1/metadata.proto\x1a,nebius/mk8s/v1alpha1/instance_template.proto\x1a$nebius/mk8s/v1alpha1/condition.proto\"\xc3\x01\n" +
	"\tNodeGroup\x12>\n" +
	"\bmetadata\x18\x01 \x01(\v2\".nebius.common.v1.ResourceMetadataR\bmetadata\x127\n" +
	"\x04spec\x18\x02 \x01(\v2#.nebius.mk8s.v1alpha1.NodeGroupSpecR\x04spec\x12=\n" +
	"\x06status\x18\x03 \x01(\v2%.nebius.mk8s.v1alpha1.NodeGroupStatusR\x06status\"\xda\x02\n" +
	"\rNodeGroupSpec\x12\x18\n" +
	"\aversion\x18\x01 \x01(\tR\aversion\x125\n" +
	"\x10fixed_node_count\x18\x02 \x01(\x03B\t\xbaH\x06\"\x04\x18d(\x00H\x00R\x0efixedNodeCount\x12R\n" +
	"\vautoscaling\x18\x05 \x01(\v2..nebius.mk8s.v1alpha1.NodeGroupAutoscalingSpecH\x00R\vautoscaling\x12F\n" +
	"\btemplate\x18\x03 \x01(\v2\".nebius.mk8s.v1alpha1.NodeTemplateB\x06\xbaH\x03\xc8\x01\x01R\btemplate\x12M\n" +
	"\bstrategy\x18\x04 \x01(\v21.nebius.mk8s.v1alpha1.NodeGroupDeploymentStrategyR\bstrategyB\r\n" +
	"\x04size\x12\x05\xbaH\x02\b\x01\"\x92\x06\n" +
	"\fNodeTemplate\x12F\n" +
	"\bmetadata\x18\x01 \x01(\v2*.nebius.mk8s.v1alpha1.NodeMetadataTemplateR\bmetadata\x127\n" +
	"\x06taints\x18\x02 \x03(\v2\x1f.nebius.mk8s.v1alpha1.NodeTaintR\x06taints\x12I\n" +
	"\tresources\x18\x03 \x01(\v2#.nebius.mk8s.v1alpha1.ResourcesSpecB\x06\xbaH\x03\xc8\x01\x01R\tresources\x12A\n" +
	"\tboot_disk\x18\t \x01(\v2\x1e.nebius.mk8s.v1alpha1.DiskSpecB\x04\xbaJ\x01\aR\bbootDisk\x12D\n" +
	"\fgpu_settings\x18\r \x01(\v2!.nebius.mk8s.v1alpha1.GpuSettingsR\vgpuSettings\x12E\n" +
	"\vgpu_cluster\x18\x04 \x01(\v2$.nebius.mk8s.v1alpha1.GpuClusterSpecR\n" +
	"gpuCluster\x12c\n" +
	"\x12network_interfaces\x18\x05 \x03(\v2..nebius.mk8s.v1alpha1.NetworkInterfaceTemplateB\x04\xbaJ\x01\aR\x11networkInterfaces\x12N\n" +
	"\vfilesystems\x18\a \x03(\v2,.nebius.mk8s.v1alpha1.AttachedFilesystemSpecR\vfilesystems\x124\n" +
	"\x14cloud_init_user_data\x18\x06 \x01(\tB\x03\xc0J\x01R\x11cloudInitUserData\x12,\n" +
	"\x12service_account_id\x18\n" +
	" \x01(\tR\x10serviceAccountId\x12M\n" +
	"\vpreemptible\x18\x0f \x01(\v2%.nebius.mk8s.v1alpha1.PreemptibleSpecB\x04\xbaJ\x01\x06R\vpreemptible\"\xa1\x01\n" +
	"\x14NodeMetadataTemplate\x12N\n" +
	"\x06labels\x18\x01 \x03(\v26.nebius.mk8s.v1alpha1.NodeMetadataTemplate.LabelsEntryR\x06labels\x1a9\n" +
	"\vLabelsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"<\n" +
	"\vGpuSettings\x12-\n" +
	"\x0edrivers_preset\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\rdriversPreset\" \n" +
	"\x0eGpuClusterSpec\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"\x96\x01\n" +
	"\x18NetworkInterfaceTemplate\x12W\n" +
	"\x11public_ip_address\x18\x01 \x01(\v2%.nebius.mk8s.v1alpha1.PublicIPAddressB\x04\xbaJ\x01\x06R\x0fpublicIpAddress\x12!\n" +
	"\tsubnet_id\x18\x03 \x01(\tB\x04\xbaJ\x01\aR\bsubnetId\"\x11\n" +
	"\x0fPublicIPAddress\"\xcd\x02\n" +
	"\x16AttachedFilesystemSpec\x12`\n" +
	"\vattach_mode\x18\x01 \x01(\x0e27.nebius.mk8s.v1alpha1.AttachedFilesystemSpec.AttachModeB\x06\xbaH\x03\xc8\x01\x01R\n" +
	"attachMode\x12'\n" +
	"\vdevice_name\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\n" +
	"deviceName\x12[\n" +
	"\x13existing_filesystem\x18\x03 \x01(\v2(.nebius.mk8s.v1alpha1.ExistingFilesystemH\x00R\x12existingFilesystem\"<\n" +
	"\n" +
	"AttachMode\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\r\n" +
	"\tREAD_ONLY\x10\x01\x12\x0e\n" +
	"\n" +
	"READ_WRITE\x10\x02B\r\n" +
	"\x04type\x12\x05\xbaH\x02\b\x01\",\n" +
	"\x12ExistingFilesystem\x12\x16\n" +
	"\x02id\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x02id\"\x8f\x02\n" +
	"\x18NodeGroupAutoscalingSpec\x12/\n" +
	"\x0emin_node_count\x18\x01 \x01(\x03B\t\xbaH\x06\"\x04\x18d(\x00R\fminNodeCount\x12/\n" +
	"\x0emax_node_count\x18\x02 \x01(\x03B\t\xbaH\x06\"\x04\x18d(\x00R\fmaxNodeCount:\x90\x01\xbaH\x8c\x01\x1a\x89\x01\n" +
	"!autoscaling.protovalidate.message\x128min_node_count must be less or equal than max_node_count\x1a*this.min_node_count <= this.max_node_count\"\x11\n" +
	"\x0fPreemptibleSpec\"\xe6\x01\n" +
	"\tNodeTaint\x12\x18\n" +
	"\x03key\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x03key\x12\x1c\n" +
	"\x05value\x18\x02 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x05value\x12F\n" +
	"\x06effect\x18\x03 \x01(\x0e2&.nebius.mk8s.v1alpha1.NodeTaint.EffectB\x06\xbaH\x03\xc8\x01\x01R\x06effect\"Y\n" +
	"\x06Effect\x12\x16\n" +
	"\x12EFFECT_UNSPECIFIED\x10\x00\x12\x0e\n" +
	"\n" +
	"NO_EXECUTE\x10\x01\x12\x0f\n" +
	"\vNO_SCHEDULE\x10\x02\x12\x16\n" +
	"\x12PREFER_NO_SCHEDULE\x10\x03\"\xef\x01\n" +
	"\x1bNodeGroupDeploymentStrategy\x12M\n" +
	"\x0fmax_unavailable\x18\x01 \x01(\v2$.nebius.mk8s.v1alpha1.PercentOrCountR\x0emaxUnavailable\x12A\n" +
	"\tmax_surge\x18\x02 \x01(\v2$.nebius.mk8s.v1alpha1.PercentOrCountR\bmaxSurge\x12>\n" +
	"\rdrain_timeout\x18\x03 \x01(\v2\x19.google.protobuf.DurationR\fdrainTimeout\"T\n" +
	"\x0ePercentOrCount\x12\x1a\n" +
	"\apercent\x18\x01 \x01(\x03H\x00R\apercent\x12\x16\n" +
	"\x05count\x18\x02 \x01(\x03H\x00R\x05countB\x0e\n" +
	"\x05value\x12\x05\xbaH\x02\b\x01\"\x94\x04\n" +
	"\x0fNodeGroupStatus\x12A\n" +
	"\x05state\x18\x01 \x01(\x0e2+.nebius.mk8s.v1alpha1.NodeGroupStatus.StateR\x05state\x12\x18\n" +
	"\aversion\x18\x02 \x01(\tR\aversion\x12*\n" +
	"\x11target_node_count\x18\x03 \x01(\x03R\x0ftargetNodeCount\x12\x1d\n" +
	"\n" +
	"node_count\x18\x04 \x01(\x03R\tnodeCount\x12.\n" +
	"\x13outdated_node_count\x18\x05 \x01(\x03R\x11outdatedNodeCount\x12(\n" +
	"\x10ready_node_count\x18\x06 \x01(\x03R\x0ereadyNodeCount\x12\x8f\x01\n" +
	"\n" +
	"conditions\x182 \x03(\v2\x1f.nebius.mk8s.v1alpha1.ConditionBN\xd2JI\n" +
	"\n" +
	"2025-08-01\x12;it is not implemented well, messages should be used instead\x18\x01R\n" +
	"conditions\x12 \n" +
	"\vreconciling\x18d \x01(\bR\vreconciling\"K\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fPROVISIONING\x10\x01\x12\v\n" +
	"\aRUNNING\x10\x02\x12\f\n" +
	"\bDELETING\x10\x03Bc\n" +
	"\x1bai.nebius.pub.mk8s.v1alpha1B\x0eNodeGroupProtoP\x01Z2github.com/nebius/gosdk/proto/nebius/mk8s/v1alpha1b\x06proto3"

var (
	file_nebius_mk8s_v1alpha1_node_group_proto_rawDescOnce sync.Once
	file_nebius_mk8s_v1alpha1_node_group_proto_rawDescData []byte
)

func file_nebius_mk8s_v1alpha1_node_group_proto_rawDescGZIP() []byte {
	file_nebius_mk8s_v1alpha1_node_group_proto_rawDescOnce.Do(func() {
		file_nebius_mk8s_v1alpha1_node_group_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_nebius_mk8s_v1alpha1_node_group_proto_rawDesc), len(file_nebius_mk8s_v1alpha1_node_group_proto_rawDesc)))
	})
	return file_nebius_mk8s_v1alpha1_node_group_proto_rawDescData
}

var file_nebius_mk8s_v1alpha1_node_group_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes = make([]protoimpl.MessageInfo, 17)
var file_nebius_mk8s_v1alpha1_node_group_proto_goTypes = []any{
	(AttachedFilesystemSpec_AttachMode)(0), // 0: nebius.mk8s.v1alpha1.AttachedFilesystemSpec.AttachMode
	(NodeTaint_Effect)(0),                  // 1: nebius.mk8s.v1alpha1.NodeTaint.Effect
	(NodeGroupStatus_State)(0),             // 2: nebius.mk8s.v1alpha1.NodeGroupStatus.State
	(*NodeGroup)(nil),                      // 3: nebius.mk8s.v1alpha1.NodeGroup
	(*NodeGroupSpec)(nil),                  // 4: nebius.mk8s.v1alpha1.NodeGroupSpec
	(*NodeTemplate)(nil),                   // 5: nebius.mk8s.v1alpha1.NodeTemplate
	(*NodeMetadataTemplate)(nil),           // 6: nebius.mk8s.v1alpha1.NodeMetadataTemplate
	(*GpuSettings)(nil),                    // 7: nebius.mk8s.v1alpha1.GpuSettings
	(*GpuClusterSpec)(nil),                 // 8: nebius.mk8s.v1alpha1.GpuClusterSpec
	(*NetworkInterfaceTemplate)(nil),       // 9: nebius.mk8s.v1alpha1.NetworkInterfaceTemplate
	(*PublicIPAddress)(nil),                // 10: nebius.mk8s.v1alpha1.PublicIPAddress
	(*AttachedFilesystemSpec)(nil),         // 11: nebius.mk8s.v1alpha1.AttachedFilesystemSpec
	(*ExistingFilesystem)(nil),             // 12: nebius.mk8s.v1alpha1.ExistingFilesystem
	(*NodeGroupAutoscalingSpec)(nil),       // 13: nebius.mk8s.v1alpha1.NodeGroupAutoscalingSpec
	(*PreemptibleSpec)(nil),                // 14: nebius.mk8s.v1alpha1.PreemptibleSpec
	(*NodeTaint)(nil),                      // 15: nebius.mk8s.v1alpha1.NodeTaint
	(*NodeGroupDeploymentStrategy)(nil),    // 16: nebius.mk8s.v1alpha1.NodeGroupDeploymentStrategy
	(*PercentOrCount)(nil),                 // 17: nebius.mk8s.v1alpha1.PercentOrCount
	(*NodeGroupStatus)(nil),                // 18: nebius.mk8s.v1alpha1.NodeGroupStatus
	nil,                                    // 19: nebius.mk8s.v1alpha1.NodeMetadataTemplate.LabelsEntry
	(*v1.ResourceMetadata)(nil),            // 20: nebius.common.v1.ResourceMetadata
	(*ResourcesSpec)(nil),                  // 21: nebius.mk8s.v1alpha1.ResourcesSpec
	(*DiskSpec)(nil),                       // 22: nebius.mk8s.v1alpha1.DiskSpec
	(*durationpb.Duration)(nil),            // 23: google.protobuf.Duration
	(*Condition)(nil),                      // 24: nebius.mk8s.v1alpha1.Condition
}
var file_nebius_mk8s_v1alpha1_node_group_proto_depIdxs = []int32{
	20, // 0: nebius.mk8s.v1alpha1.NodeGroup.metadata:type_name -> nebius.common.v1.ResourceMetadata
	4,  // 1: nebius.mk8s.v1alpha1.NodeGroup.spec:type_name -> nebius.mk8s.v1alpha1.NodeGroupSpec
	18, // 2: nebius.mk8s.v1alpha1.NodeGroup.status:type_name -> nebius.mk8s.v1alpha1.NodeGroupStatus
	13, // 3: nebius.mk8s.v1alpha1.NodeGroupSpec.autoscaling:type_name -> nebius.mk8s.v1alpha1.NodeGroupAutoscalingSpec
	5,  // 4: nebius.mk8s.v1alpha1.NodeGroupSpec.template:type_name -> nebius.mk8s.v1alpha1.NodeTemplate
	16, // 5: nebius.mk8s.v1alpha1.NodeGroupSpec.strategy:type_name -> nebius.mk8s.v1alpha1.NodeGroupDeploymentStrategy
	6,  // 6: nebius.mk8s.v1alpha1.NodeTemplate.metadata:type_name -> nebius.mk8s.v1alpha1.NodeMetadataTemplate
	15, // 7: nebius.mk8s.v1alpha1.NodeTemplate.taints:type_name -> nebius.mk8s.v1alpha1.NodeTaint
	21, // 8: nebius.mk8s.v1alpha1.NodeTemplate.resources:type_name -> nebius.mk8s.v1alpha1.ResourcesSpec
	22, // 9: nebius.mk8s.v1alpha1.NodeTemplate.boot_disk:type_name -> nebius.mk8s.v1alpha1.DiskSpec
	7,  // 10: nebius.mk8s.v1alpha1.NodeTemplate.gpu_settings:type_name -> nebius.mk8s.v1alpha1.GpuSettings
	8,  // 11: nebius.mk8s.v1alpha1.NodeTemplate.gpu_cluster:type_name -> nebius.mk8s.v1alpha1.GpuClusterSpec
	9,  // 12: nebius.mk8s.v1alpha1.NodeTemplate.network_interfaces:type_name -> nebius.mk8s.v1alpha1.NetworkInterfaceTemplate
	11, // 13: nebius.mk8s.v1alpha1.NodeTemplate.filesystems:type_name -> nebius.mk8s.v1alpha1.AttachedFilesystemSpec
	14, // 14: nebius.mk8s.v1alpha1.NodeTemplate.preemptible:type_name -> nebius.mk8s.v1alpha1.PreemptibleSpec
	19, // 15: nebius.mk8s.v1alpha1.NodeMetadataTemplate.labels:type_name -> nebius.mk8s.v1alpha1.NodeMetadataTemplate.LabelsEntry
	10, // 16: nebius.mk8s.v1alpha1.NetworkInterfaceTemplate.public_ip_address:type_name -> nebius.mk8s.v1alpha1.PublicIPAddress
	0,  // 17: nebius.mk8s.v1alpha1.AttachedFilesystemSpec.attach_mode:type_name -> nebius.mk8s.v1alpha1.AttachedFilesystemSpec.AttachMode
	12, // 18: nebius.mk8s.v1alpha1.AttachedFilesystemSpec.existing_filesystem:type_name -> nebius.mk8s.v1alpha1.ExistingFilesystem
	1,  // 19: nebius.mk8s.v1alpha1.NodeTaint.effect:type_name -> nebius.mk8s.v1alpha1.NodeTaint.Effect
	17, // 20: nebius.mk8s.v1alpha1.NodeGroupDeploymentStrategy.max_unavailable:type_name -> nebius.mk8s.v1alpha1.PercentOrCount
	17, // 21: nebius.mk8s.v1alpha1.NodeGroupDeploymentStrategy.max_surge:type_name -> nebius.mk8s.v1alpha1.PercentOrCount
	23, // 22: nebius.mk8s.v1alpha1.NodeGroupDeploymentStrategy.drain_timeout:type_name -> google.protobuf.Duration
	2,  // 23: nebius.mk8s.v1alpha1.NodeGroupStatus.state:type_name -> nebius.mk8s.v1alpha1.NodeGroupStatus.State
	24, // 24: nebius.mk8s.v1alpha1.NodeGroupStatus.conditions:type_name -> nebius.mk8s.v1alpha1.Condition
	25, // [25:25] is the sub-list for method output_type
	25, // [25:25] is the sub-list for method input_type
	25, // [25:25] is the sub-list for extension type_name
	25, // [25:25] is the sub-list for extension extendee
	0,  // [0:25] is the sub-list for field type_name
}

func init() { file_nebius_mk8s_v1alpha1_node_group_proto_init() }
func file_nebius_mk8s_v1alpha1_node_group_proto_init() {
	if File_nebius_mk8s_v1alpha1_node_group_proto != nil {
		return
	}
	file_nebius_mk8s_v1alpha1_instance_template_proto_init()
	file_nebius_mk8s_v1alpha1_condition_proto_init()
	file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[1].OneofWrappers = []any{
		(*NodeGroupSpec_FixedNodeCount)(nil),
		(*NodeGroupSpec_Autoscaling)(nil),
	}
	file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[8].OneofWrappers = []any{
		(*AttachedFilesystemSpec_ExistingFilesystem)(nil),
	}
	file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes[14].OneofWrappers = []any{
		(*PercentOrCount_Percent)(nil),
		(*PercentOrCount_Count)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_nebius_mk8s_v1alpha1_node_group_proto_rawDesc), len(file_nebius_mk8s_v1alpha1_node_group_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   17,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_nebius_mk8s_v1alpha1_node_group_proto_goTypes,
		DependencyIndexes: file_nebius_mk8s_v1alpha1_node_group_proto_depIdxs,
		EnumInfos:         file_nebius_mk8s_v1alpha1_node_group_proto_enumTypes,
		MessageInfos:      file_nebius_mk8s_v1alpha1_node_group_proto_msgTypes,
	}.Build()
	File_nebius_mk8s_v1alpha1_node_group_proto = out.File
	file_nebius_mk8s_v1alpha1_node_group_proto_goTypes = nil
	file_nebius_mk8s_v1alpha1_node_group_proto_depIdxs = nil
}

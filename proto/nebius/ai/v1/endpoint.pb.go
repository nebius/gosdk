// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.28.3
// source: nebius/ai/v1/endpoint.proto

package v1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	_ "github.com/nebius/gosdk/proto/nebius"
	v1 "github.com/nebius/gosdk/proto/nebius/common/v1"
	v11 "github.com/nebius/gosdk/proto/nebius/compute/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Represents protocol of the endpoint's port which will be exposed.
type EndpointSpec_Port_Protocol int32

const (
	EndpointSpec_Port_PROTOCOL_UNSPECIFIED EndpointSpec_Port_Protocol = 0
	// HTTP protocol.
	EndpointSpec_Port_HTTP EndpointSpec_Port_Protocol = 1
	// TCP protocol.
	EndpointSpec_Port_TCP EndpointSpec_Port_Protocol = 2
	// UDP protocol.
	EndpointSpec_Port_UDP EndpointSpec_Port_Protocol = 3
)

// Enum value maps for EndpointSpec_Port_Protocol.
var (
	EndpointSpec_Port_Protocol_name = map[int32]string{
		0: "PROTOCOL_UNSPECIFIED",
		1: "HTTP",
		2: "TCP",
		3: "UDP",
	}
	EndpointSpec_Port_Protocol_value = map[string]int32{
		"PROTOCOL_UNSPECIFIED": 0,
		"HTTP":                 1,
		"TCP":                  2,
		"UDP":                  3,
	}
)

func (x EndpointSpec_Port_Protocol) Enum() *EndpointSpec_Port_Protocol {
	p := new(EndpointSpec_Port_Protocol)
	*p = x
	return p
}

func (x EndpointSpec_Port_Protocol) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EndpointSpec_Port_Protocol) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_ai_v1_endpoint_proto_enumTypes[0].Descriptor()
}

func (EndpointSpec_Port_Protocol) Type() protoreflect.EnumType {
	return &file_nebius_ai_v1_endpoint_proto_enumTypes[0]
}

func (x EndpointSpec_Port_Protocol) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EndpointSpec_Port_Protocol.Descriptor instead.
func (EndpointSpec_Port_Protocol) EnumDescriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{1, 1, 0}
}

// Mode that will be used to mount the volume.
type EndpointSpec_VolumeMount_Mode int32

const (
	EndpointSpec_VolumeMount_MODE_UNSPECIFIED EndpointSpec_VolumeMount_Mode = 0
	// Read-only mode.
	EndpointSpec_VolumeMount_READ_ONLY EndpointSpec_VolumeMount_Mode = 1
	// Read-write mode.
	EndpointSpec_VolumeMount_READ_WRITE EndpointSpec_VolumeMount_Mode = 2
)

// Enum value maps for EndpointSpec_VolumeMount_Mode.
var (
	EndpointSpec_VolumeMount_Mode_name = map[int32]string{
		0: "MODE_UNSPECIFIED",
		1: "READ_ONLY",
		2: "READ_WRITE",
	}
	EndpointSpec_VolumeMount_Mode_value = map[string]int32{
		"MODE_UNSPECIFIED": 0,
		"READ_ONLY":        1,
		"READ_WRITE":       2,
	}
)

func (x EndpointSpec_VolumeMount_Mode) Enum() *EndpointSpec_VolumeMount_Mode {
	p := new(EndpointSpec_VolumeMount_Mode)
	*p = x
	return p
}

func (x EndpointSpec_VolumeMount_Mode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EndpointSpec_VolumeMount_Mode) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_ai_v1_endpoint_proto_enumTypes[1].Descriptor()
}

func (EndpointSpec_VolumeMount_Mode) Type() protoreflect.EnumType {
	return &file_nebius_ai_v1_endpoint_proto_enumTypes[1]
}

func (x EndpointSpec_VolumeMount_Mode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EndpointSpec_VolumeMount_Mode.Descriptor instead.
func (EndpointSpec_VolumeMount_Mode) EnumDescriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{1, 2, 0}
}

// Endpoint state.
type EndpointStatus_State int32

const (
	EndpointStatus_STATE_UNSPECIFIED EndpointStatus_State = 0
	// The endpoint is creating resources.
	EndpointStatus_PROVISIONING EndpointStatus_State = 1
	// The endpoint is being started.
	EndpointStatus_STARTING EndpointStatus_State = 2
	// The endpoint is running.
	EndpointStatus_RUNNING EndpointStatus_State = 3
	// The endpoint is being stopped.
	EndpointStatus_STOPPING EndpointStatus_State = 4
	// The endpoint is being deleted.
	EndpointStatus_DELETING EndpointStatus_State = 5
	// The endpoint has been stopped.
	EndpointStatus_STOPPED EndpointStatus_State = 6
	// The endpoint encountered an error.
	EndpointStatus_ERROR EndpointStatus_State = 8
)

// Enum value maps for EndpointStatus_State.
var (
	EndpointStatus_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "PROVISIONING",
		2: "STARTING",
		3: "RUNNING",
		4: "STOPPING",
		5: "DELETING",
		6: "STOPPED",
		8: "ERROR",
	}
	EndpointStatus_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"PROVISIONING":      1,
		"STARTING":          2,
		"RUNNING":           3,
		"STOPPING":          4,
		"DELETING":          5,
		"STOPPED":           6,
		"ERROR":             8,
	}
)

func (x EndpointStatus_State) Enum() *EndpointStatus_State {
	p := new(EndpointStatus_State)
	*p = x
	return p
}

func (x EndpointStatus_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EndpointStatus_State) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_ai_v1_endpoint_proto_enumTypes[2].Descriptor()
}

func (EndpointStatus_State) Type() protoreflect.EnumType {
	return &file_nebius_ai_v1_endpoint_proto_enumTypes[2]
}

func (x EndpointStatus_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EndpointStatus_State.Descriptor instead.
func (EndpointStatus_State) EnumDescriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{2, 0}
}

// Endpoint instance state.
type EndpointInstanceStatus_State int32

const (
	EndpointInstanceStatus_STATE_UNSPECIFIED EndpointInstanceStatus_State = 0
	// The endpoint is creating resources.
	EndpointInstanceStatus_PROVISIONING EndpointInstanceStatus_State = 1
	// The endpoint is being started.
	EndpointInstanceStatus_STARTING EndpointInstanceStatus_State = 2
	// The endpoint is running.
	EndpointInstanceStatus_RUNNING EndpointInstanceStatus_State = 3
	// The endpoint is being stopped.
	EndpointInstanceStatus_STOPPING EndpointInstanceStatus_State = 4
	// The endpoint is being deleted.
	EndpointInstanceStatus_DELETING EndpointInstanceStatus_State = 5
	// The endpoint has been stopped.
	EndpointInstanceStatus_STOPPED EndpointInstanceStatus_State = 6
	// The endpoint has failed.
	EndpointInstanceStatus_FAILED EndpointInstanceStatus_State = 7
	// The endpoint encountered an error.
	EndpointInstanceStatus_ERROR EndpointInstanceStatus_State = 8
)

// Enum value maps for EndpointInstanceStatus_State.
var (
	EndpointInstanceStatus_State_name = map[int32]string{
		0: "STATE_UNSPECIFIED",
		1: "PROVISIONING",
		2: "STARTING",
		3: "RUNNING",
		4: "STOPPING",
		5: "DELETING",
		6: "STOPPED",
		7: "FAILED",
		8: "ERROR",
	}
	EndpointInstanceStatus_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"PROVISIONING":      1,
		"STARTING":          2,
		"RUNNING":           3,
		"STOPPING":          4,
		"DELETING":          5,
		"STOPPED":           6,
		"FAILED":            7,
		"ERROR":             8,
	}
)

func (x EndpointInstanceStatus_State) Enum() *EndpointInstanceStatus_State {
	p := new(EndpointInstanceStatus_State)
	*p = x
	return p
}

func (x EndpointInstanceStatus_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EndpointInstanceStatus_State) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_ai_v1_endpoint_proto_enumTypes[3].Descriptor()
}

func (EndpointInstanceStatus_State) Type() protoreflect.EnumType {
	return &file_nebius_ai_v1_endpoint_proto_enumTypes[3]
}

func (x EndpointInstanceStatus_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EndpointInstanceStatus_State.Descriptor instead.
func (EndpointInstanceStatus_State) EnumDescriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{4, 0}
}

// Represents an endpoint with a specified workload.
type Endpoint struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Metadata      *v1.ResourceMetadata   `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Spec          *EndpointSpec          `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	Status        *EndpointStatus        `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Endpoint) Reset() {
	*x = Endpoint{}
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Endpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Endpoint) ProtoMessage() {}

func (x *Endpoint) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Endpoint.ProtoReflect.Descriptor instead.
func (*Endpoint) Descriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{0}
}

func (x *Endpoint) GetMetadata() *v1.ResourceMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Endpoint) GetSpec() *EndpointSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Endpoint) GetStatus() *EndpointStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// EndpointSpec defines a endpoint that will be run.
type EndpointSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The Docker image to use for the endpoint's container.
	Image string `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	// Specifies the environment variables for the endpoint's container.
	EnvironmentVariables []*EndpointSpec_EnvironmentVariable `protobuf:"bytes,2,rep,name=environment_variables,json=environmentVariables,proto3" json:"environment_variables,omitempty"`
	// Specifies the ports that the endpoint exposes.
	Ports []*EndpointSpec_Port `protobuf:"bytes,3,rep,name=ports,proto3" json:"ports,omitempty"`
	// The entrypoint command for the endpoint's container.
	ContainerCommand string `protobuf:"bytes,4,opt,name=container_command,json=containerCommand,proto3" json:"container_command,omitempty"`
	// The arguments to pass to the entrypoint command.
	Args string `protobuf:"bytes,5,opt,name=args,proto3" json:"args,omitempty"`
	// The working directory for the endpoint's container.
	WorkingDir string `protobuf:"bytes,6,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	// Volumes to be mounted into the endpoint's container.
	Volumes []*EndpointSpec_VolumeMount `protobuf:"bytes,7,rep,name=volumes,proto3" json:"volumes,omitempty"`
	// Registry credentials for private Docker registry.
	RegistryCredentials *EndpointSpec_RegistryCredentials `protobuf:"bytes,10,opt,name=registry_credentials,json=registryCredentials,proto3" json:"registry_credentials,omitempty"`
	// Compute platform that the endpoint will be run on.
	Platform string `protobuf:"bytes,20,opt,name=platform,proto3" json:"platform,omitempty"`
	// Compute preset that the endpoint will be run on.
	Preset string `protobuf:"bytes,21,opt,name=preset,proto3" json:"preset,omitempty"`
	// Shared memory size in bytes for the endpoint's container.
	ShmSizeBytes int64 `protobuf:"varint,22,opt,name=shm_size_bytes,json=shmSizeBytes,proto3" json:"shm_size_bytes,omitempty"`
	// Disk spec for the main disk of the endpoint.
	Disk *EndpointSpec_DiskSpec `protobuf:"bytes,23,opt,name=disk,proto3" json:"disk,omitempty"`
	// Subnet ID where the endpoint will be deployed.
	SubnetId string `protobuf:"bytes,24,opt,name=subnet_id,json=subnetId,proto3" json:"subnet_id,omitempty"`
	// Whether to assign a public IP to the endpoint.
	PublicIp bool `protobuf:"varint,25,opt,name=public_ip,json=publicIp,proto3" json:"public_ip,omitempty"`
	// Public keys to be authorized for SSH access to the job.
	SshAuthorizedKeys []string `protobuf:"bytes,26,rep,name=ssh_authorized_keys,json=sshAuthorizedKeys,proto3" json:"ssh_authorized_keys,omitempty"`
	// Authentication token needed to access the endpoint.
	//
	// Authentication can only be enabled if the endpoint exposes one and only one HTTP port.
	//
	// If not provided, a authentication will be disabled.
	AuthToken     string `protobuf:"bytes,30,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EndpointSpec) Reset() {
	*x = EndpointSpec{}
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointSpec) ProtoMessage() {}

func (x *EndpointSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointSpec.ProtoReflect.Descriptor instead.
func (*EndpointSpec) Descriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{1}
}

func (x *EndpointSpec) GetImage() string {
	if x != nil {
		return x.Image
	}
	return ""
}

func (x *EndpointSpec) GetEnvironmentVariables() []*EndpointSpec_EnvironmentVariable {
	if x != nil {
		return x.EnvironmentVariables
	}
	return nil
}

func (x *EndpointSpec) GetPorts() []*EndpointSpec_Port {
	if x != nil {
		return x.Ports
	}
	return nil
}

func (x *EndpointSpec) GetContainerCommand() string {
	if x != nil {
		return x.ContainerCommand
	}
	return ""
}

func (x *EndpointSpec) GetArgs() string {
	if x != nil {
		return x.Args
	}
	return ""
}

func (x *EndpointSpec) GetWorkingDir() string {
	if x != nil {
		return x.WorkingDir
	}
	return ""
}

func (x *EndpointSpec) GetVolumes() []*EndpointSpec_VolumeMount {
	if x != nil {
		return x.Volumes
	}
	return nil
}

func (x *EndpointSpec) GetRegistryCredentials() *EndpointSpec_RegistryCredentials {
	if x != nil {
		return x.RegistryCredentials
	}
	return nil
}

func (x *EndpointSpec) GetPlatform() string {
	if x != nil {
		return x.Platform
	}
	return ""
}

func (x *EndpointSpec) GetPreset() string {
	if x != nil {
		return x.Preset
	}
	return ""
}

func (x *EndpointSpec) GetShmSizeBytes() int64 {
	if x != nil {
		return x.ShmSizeBytes
	}
	return 0
}

func (x *EndpointSpec) GetDisk() *EndpointSpec_DiskSpec {
	if x != nil {
		return x.Disk
	}
	return nil
}

func (x *EndpointSpec) GetSubnetId() string {
	if x != nil {
		return x.SubnetId
	}
	return ""
}

func (x *EndpointSpec) GetPublicIp() bool {
	if x != nil {
		return x.PublicIp
	}
	return false
}

func (x *EndpointSpec) GetSshAuthorizedKeys() []string {
	if x != nil {
		return x.SshAuthorizedKeys
	}
	return nil
}

func (x *EndpointSpec) GetAuthToken() string {
	if x != nil {
		return x.AuthToken
	}
	return ""
}

// EndpointStatus represents the status of a VM app.
type EndpointStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Private endpoints to access the workload.
	PrivateEndpoints []string `protobuf:"bytes,1,rep,name=private_endpoints,json=privateEndpoints,proto3" json:"private_endpoints,omitempty"`
	// Public endpoints to access the workload.
	PublicEndpoints []string `protobuf:"bytes,2,rep,name=public_endpoints,json=publicEndpoints,proto3" json:"public_endpoints,omitempty"`
	// Status of individual endpoint instances.
	Instances []*EndpointInstanceStatus `protobuf:"bytes,10,rep,name=instances,proto3" json:"instances,omitempty"`
	// State of the endpoint.
	State EndpointStatus_State `protobuf:"varint,20,opt,name=state,proto3,enum=nebius.ai.v1.EndpointStatus_State" json:"state,omitempty"`
	// Details of the endpoint's state.
	StateDetails  *EndpointStateDetails `protobuf:"bytes,21,opt,name=state_details,json=stateDetails,proto3" json:"state_details,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EndpointStatus) Reset() {
	*x = EndpointStatus{}
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointStatus) ProtoMessage() {}

func (x *EndpointStatus) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointStatus.ProtoReflect.Descriptor instead.
func (*EndpointStatus) Descriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{2}
}

func (x *EndpointStatus) GetPrivateEndpoints() []string {
	if x != nil {
		return x.PrivateEndpoints
	}
	return nil
}

func (x *EndpointStatus) GetPublicEndpoints() []string {
	if x != nil {
		return x.PublicEndpoints
	}
	return nil
}

func (x *EndpointStatus) GetInstances() []*EndpointInstanceStatus {
	if x != nil {
		return x.Instances
	}
	return nil
}

func (x *EndpointStatus) GetState() EndpointStatus_State {
	if x != nil {
		return x.State
	}
	return EndpointStatus_STATE_UNSPECIFIED
}

func (x *EndpointStatus) GetStateDetails() *EndpointStateDetails {
	if x != nil {
		return x.StateDetails
	}
	return nil
}

// Endpoint state details.
type EndpointStateDetails struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Short state description.
	Code string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	// Detailed human-readable description.
	Message       string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EndpointStateDetails) Reset() {
	*x = EndpointStateDetails{}
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointStateDetails) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointStateDetails) ProtoMessage() {}

func (x *EndpointStateDetails) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointStateDetails.ProtoReflect.Descriptor instead.
func (*EndpointStateDetails) Descriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{3}
}

func (x *EndpointStateDetails) GetCode() string {
	if x != nil {
		return x.Code
	}
	return ""
}

func (x *EndpointStateDetails) GetMessage() string {
	if x != nil {
		return x.Message
	}
	return ""
}

// EndpointInstanceStatus represents the status of a endpoint instance.
type EndpointInstanceStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The current state of the endpoint's workload.
	State EndpointInstanceStatus_State `protobuf:"varint,1,opt,name=state,proto3,enum=nebius.ai.v1.EndpointInstanceStatus_State" json:"state,omitempty"`
	// ID of the compute instance running the endpoint.
	ComputeInstanceId string `protobuf:"bytes,10,opt,name=compute_instance_id,json=computeInstanceId,proto3" json:"compute_instance_id,omitempty"`
	// The current state of the compute instance.
	ComputeInstanceState v11.InstanceStatus_InstanceState `protobuf:"varint,11,opt,name=compute_instance_state,json=computeInstanceState,proto3,enum=nebius.compute.v1.InstanceStatus_InstanceState" json:"compute_instance_state,omitempty"`
	// Private IP address of the instance.
	PrivateIp string `protobuf:"bytes,12,opt,name=private_ip,json=privateIp,proto3" json:"private_ip,omitempty"`
	// Public IP address of the instance.
	PublicIp      string `protobuf:"bytes,13,opt,name=public_ip,json=publicIp,proto3" json:"public_ip,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EndpointInstanceStatus) Reset() {
	*x = EndpointInstanceStatus{}
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointInstanceStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointInstanceStatus) ProtoMessage() {}

func (x *EndpointInstanceStatus) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointInstanceStatus.ProtoReflect.Descriptor instead.
func (*EndpointInstanceStatus) Descriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{4}
}

func (x *EndpointInstanceStatus) GetState() EndpointInstanceStatus_State {
	if x != nil {
		return x.State
	}
	return EndpointInstanceStatus_STATE_UNSPECIFIED
}

func (x *EndpointInstanceStatus) GetComputeInstanceId() string {
	if x != nil {
		return x.ComputeInstanceId
	}
	return ""
}

func (x *EndpointInstanceStatus) GetComputeInstanceState() v11.InstanceStatus_InstanceState {
	if x != nil {
		return x.ComputeInstanceState
	}
	return v11.InstanceStatus_InstanceState(0)
}

func (x *EndpointInstanceStatus) GetPrivateIp() string {
	if x != nil {
		return x.PrivateIp
	}
	return ""
}

func (x *EndpointInstanceStatus) GetPublicIp() string {
	if x != nil {
		return x.PublicIp
	}
	return ""
}

// EnvironmentVariable defines an environment variable for the endpoint's container.
type EndpointSpec_EnvironmentVariable struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the environment variable.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Environment variable value.
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EndpointSpec_EnvironmentVariable) Reset() {
	*x = EndpointSpec_EnvironmentVariable{}
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointSpec_EnvironmentVariable) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointSpec_EnvironmentVariable) ProtoMessage() {}

func (x *EndpointSpec_EnvironmentVariable) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointSpec_EnvironmentVariable.ProtoReflect.Descriptor instead.
func (*EndpointSpec_EnvironmentVariable) Descriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{1, 0}
}

func (x *EndpointSpec_EnvironmentVariable) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *EndpointSpec_EnvironmentVariable) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type EndpointSpec_Port struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Container port.
	ContainerPort int32 `protobuf:"varint,1,opt,name=container_port,json=containerPort,proto3" json:"container_port,omitempty"`
	// Host port.
	//
	// If not specified, will be same as container_port.
	HostPort int32 `protobuf:"varint,2,opt,name=host_port,json=hostPort,proto3" json:"host_port,omitempty"`
	// Port's protocol.
	Protocol      EndpointSpec_Port_Protocol `protobuf:"varint,3,opt,name=protocol,proto3,enum=nebius.ai.v1.EndpointSpec_Port_Protocol" json:"protocol,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EndpointSpec_Port) Reset() {
	*x = EndpointSpec_Port{}
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointSpec_Port) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointSpec_Port) ProtoMessage() {}

func (x *EndpointSpec_Port) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointSpec_Port.ProtoReflect.Descriptor instead.
func (*EndpointSpec_Port) Descriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{1, 1}
}

func (x *EndpointSpec_Port) GetContainerPort() int32 {
	if x != nil {
		return x.ContainerPort
	}
	return 0
}

func (x *EndpointSpec_Port) GetHostPort() int32 {
	if x != nil {
		return x.HostPort
	}
	return 0
}

func (x *EndpointSpec_Port) GetProtocol() EndpointSpec_Port_Protocol {
	if x != nil {
		return x.Protocol
	}
	return EndpointSpec_Port_PROTOCOL_UNSPECIFIED
}

// VolumeMount represents a volume mount for the endpoint's container.
type EndpointSpec_VolumeMount struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Source of the volume mount.
	//
	// Can be a name of an ID of Nebius Storage bucket or filesystem.
	Source string `protobuf:"bytes,1,opt,name=source,proto3" json:"source,omitempty"`
	// Path inside the source volume.
	//
	// Optional.
	SourcePath string `protobuf:"bytes,2,opt,name=source_path,json=sourcePath,proto3" json:"source_path,omitempty"`
	// Path inside the endpoint's container where the volume is mounted.
	//
	// Must be an absolute path.
	ContainerPath string `protobuf:"bytes,3,opt,name=container_path,json=containerPath,proto3" json:"container_path,omitempty"`
	// Mount mode.
	Mode          EndpointSpec_VolumeMount_Mode `protobuf:"varint,4,opt,name=mode,proto3,enum=nebius.ai.v1.EndpointSpec_VolumeMount_Mode" json:"mode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EndpointSpec_VolumeMount) Reset() {
	*x = EndpointSpec_VolumeMount{}
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointSpec_VolumeMount) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointSpec_VolumeMount) ProtoMessage() {}

func (x *EndpointSpec_VolumeMount) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointSpec_VolumeMount.ProtoReflect.Descriptor instead.
func (*EndpointSpec_VolumeMount) Descriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{1, 2}
}

func (x *EndpointSpec_VolumeMount) GetSource() string {
	if x != nil {
		return x.Source
	}
	return ""
}

func (x *EndpointSpec_VolumeMount) GetSourcePath() string {
	if x != nil {
		return x.SourcePath
	}
	return ""
}

func (x *EndpointSpec_VolumeMount) GetContainerPath() string {
	if x != nil {
		return x.ContainerPath
	}
	return ""
}

func (x *EndpointSpec_VolumeMount) GetMode() EndpointSpec_VolumeMount_Mode {
	if x != nil {
		return x.Mode
	}
	return EndpointSpec_VolumeMount_MODE_UNSPECIFIED
}

type EndpointSpec_DiskSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Disk type.
	Type v11.DiskSpec_DiskType `protobuf:"varint,1,opt,name=type,proto3,enum=nebius.compute.v1.DiskSpec_DiskType" json:"type,omitempty"`
	// Disk size in bytes.
	SizeBytes     int64 `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EndpointSpec_DiskSpec) Reset() {
	*x = EndpointSpec_DiskSpec{}
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointSpec_DiskSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointSpec_DiskSpec) ProtoMessage() {}

func (x *EndpointSpec_DiskSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointSpec_DiskSpec.ProtoReflect.Descriptor instead.
func (*EndpointSpec_DiskSpec) Descriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{1, 3}
}

func (x *EndpointSpec_DiskSpec) GetType() v11.DiskSpec_DiskType {
	if x != nil {
		return x.Type
	}
	return v11.DiskSpec_DiskType(0)
}

func (x *EndpointSpec_DiskSpec) GetSizeBytes() int64 {
	if x != nil {
		return x.SizeBytes
	}
	return 0
}

type EndpointSpec_RegistryCredentials struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Registry username for private Docker registry.
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	// Registry password for private Docker registry.
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	// Secret version storing the registry credentials.
	// Must have keys "REGISTRY_USERNAME" and "REGISTRY_PASSWORD".
	MysteryboxSecretVersion string `protobuf:"bytes,3,opt,name=mysterybox_secret_version,json=mysteryboxSecretVersion,proto3" json:"mysterybox_secret_version,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *EndpointSpec_RegistryCredentials) Reset() {
	*x = EndpointSpec_RegistryCredentials{}
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EndpointSpec_RegistryCredentials) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EndpointSpec_RegistryCredentials) ProtoMessage() {}

func (x *EndpointSpec_RegistryCredentials) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_ai_v1_endpoint_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EndpointSpec_RegistryCredentials.ProtoReflect.Descriptor instead.
func (*EndpointSpec_RegistryCredentials) Descriptor() ([]byte, []int) {
	return file_nebius_ai_v1_endpoint_proto_rawDescGZIP(), []int{1, 4}
}

func (x *EndpointSpec_RegistryCredentials) GetUsername() string {
	if x != nil {
		return x.Username
	}
	return ""
}

func (x *EndpointSpec_RegistryCredentials) GetPassword() string {
	if x != nil {
		return x.Password
	}
	return ""
}

func (x *EndpointSpec_RegistryCredentials) GetMysteryboxSecretVersion() string {
	if x != nil {
		return x.MysteryboxSecretVersion
	}
	return ""
}

var File_nebius_ai_v1_endpoint_proto protoreflect.FileDescriptor

const file_nebius_ai_v1_endpoint_proto_rawDesc = "" +
	"\n" +
	"\x1bnebius/ai/v1/endpoint.proto\x12\fnebius.ai.v1\x1a\x1bbuf/validate/validate.proto\x1a\x18nebius/annotations.proto\x1a\x1fnebius/common/v1/metadata.proto\x1a\x1cnebius/compute/v1/disk.proto\x1a nebius/compute/v1/instance.proto\"\xc6\x01\n" +
	"\bEndpoint\x12F\n" +
	"\bmetadata\x18\x01 \x01(\v2\".nebius.common.v1.ResourceMetadataB\x06\xbaH\x03\xc8\x01\x01R\bmetadata\x126\n" +
	"\x04spec\x18\x02 \x01(\v2\x1a.nebius.ai.v1.EndpointSpecB\x06\xbaH\x03\xc8\x01\x01R\x04spec\x12:\n" +
	"\x06status\x18\x03 \x01(\v2\x1c.nebius.ai.v1.EndpointStatusB\x04\xbaJ\x01\x05R\x06status\"\x91\r\n" +
	"\fEndpointSpec\x12\x1c\n" +
	"\x05image\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x05image\x12c\n" +
	"\x15environment_variables\x18\x02 \x03(\v2..nebius.ai.v1.EndpointSpec.EnvironmentVariableR\x14environmentVariables\x125\n" +
	"\x05ports\x18\x03 \x03(\v2\x1f.nebius.ai.v1.EndpointSpec.PortR\x05ports\x12+\n" +
	"\x11container_command\x18\x04 \x01(\tR\x10containerCommand\x12\x12\n" +
	"\x04args\x18\x05 \x01(\tR\x04args\x12)\n" +
	"\vworking_dir\x18\x06 \x01(\tB\b\xbaH\x05r\x03\x18\x80\x01R\n" +
	"workingDir\x12@\n" +
	"\avolumes\x18\a \x03(\v2&.nebius.ai.v1.EndpointSpec.VolumeMountR\avolumes\x12a\n" +
	"\x14registry_credentials\x18\n" +
	" \x01(\v2..nebius.ai.v1.EndpointSpec.RegistryCredentialsR\x13registryCredentials\x12\"\n" +
	"\bplatform\x18\x14 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\bplatform\x12\x1e\n" +
	"\x06preset\x18\x15 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x06preset\x12-\n" +
	"\x0eshm_size_bytes\x18\x16 \x01(\x03B\a\xbaH\x04\"\x02(\x00R\fshmSizeBytes\x12?\n" +
	"\x04disk\x18\x17 \x01(\v2#.nebius.ai.v1.EndpointSpec.DiskSpecB\x06\xbaH\x03\xc8\x01\x01R\x04disk\x121\n" +
	"\tsubnet_id\x18\x18 \x01(\tB\x14\xbaH\x03\xc8\x01\x01\xe2J\v\n" +
	"\tvpcsubnetR\bsubnetId\x12\x1b\n" +
	"\tpublic_ip\x18\x19 \x01(\bR\bpublicIp\x12.\n" +
	"\x13ssh_authorized_keys\x18\x1a \x03(\tR\x11sshAuthorizedKeys\x12\"\n" +
	"\n" +
	"auth_token\x18\x1e \x01(\tB\x03\xc0J\x01R\tauthToken\x1aL\n" +
	"\x13EnvironmentVariable\x12\x1a\n" +
	"\x04name\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04name\x12\x19\n" +
	"\x05value\x18\x02 \x01(\tB\x03\xc0J\x01R\x05value\x1a\xf4\x01\n" +
	"\x04Port\x122\n" +
	"\x0econtainer_port\x18\x01 \x01(\x05B\v\xbaH\b\x1a\x06\x18\xff\xff\x03(\x01R\rcontainerPort\x12(\n" +
	"\thost_port\x18\x02 \x01(\x05B\v\xbaH\b\x1a\x06\x18\xff\xff\x03(\x00R\bhostPort\x12L\n" +
	"\bprotocol\x18\x03 \x01(\x0e2(.nebius.ai.v1.EndpointSpec.Port.ProtocolB\x06\xbaH\x03\xc8\x01\x01R\bprotocol\"@\n" +
	"\bProtocol\x12\x18\n" +
	"\x14PROTOCOL_UNSPECIFIED\x10\x00\x12\b\n" +
	"\x04HTTP\x10\x01\x12\a\n" +
	"\x03TCP\x10\x02\x12\a\n" +
	"\x03UDP\x10\x03\x1a\x9a\x02\n" +
	"\vVolumeMount\x12=\n" +
	"\x06source\x18\x01 \x01(\tB%\xe2J\"\n" +
	"\x11computefilesystem\n" +
	"\rstoragebucketR\x06source\x12\x1f\n" +
	"\vsource_path\x18\x02 \x01(\tR\n" +
	"sourcePath\x12%\n" +
	"\x0econtainer_path\x18\x03 \x01(\tR\rcontainerPath\x12G\n" +
	"\x04mode\x18\x04 \x01(\x0e2+.nebius.ai.v1.EndpointSpec.VolumeMount.ModeB\x06\xbaH\x03\xc8\x01\x01R\x04mode\";\n" +
	"\x04Mode\x12\x14\n" +
	"\x10MODE_UNSPECIFIED\x10\x00\x12\r\n" +
	"\tREAD_ONLY\x10\x01\x12\x0e\n" +
	"\n" +
	"READ_WRITE\x10\x02\x1ak\n" +
	"\bDiskSpec\x12@\n" +
	"\x04type\x18\x01 \x01(\x0e2$.nebius.compute.v1.DiskSpec.DiskTypeB\x06\xbaH\x03\xc8\x01\x01R\x04type\x12\x1d\n" +
	"\n" +
	"size_bytes\x18\x02 \x01(\x03R\tsizeBytes\x1a\x8e\x01\n" +
	"\x13RegistryCredentials\x12\x1a\n" +
	"\busername\x18\x01 \x01(\tR\busername\x12\x1f\n" +
	"\bpassword\x18\x02 \x01(\tB\x03\xc0J\x01R\bpassword\x12:\n" +
	"\x19mysterybox_secret_version\x18\x03 \x01(\tR\x17mysteryboxSecretVersion\"\xb0\x03\n" +
	"\x0eEndpointStatus\x12+\n" +
	"\x11private_endpoints\x18\x01 \x03(\tR\x10privateEndpoints\x12)\n" +
	"\x10public_endpoints\x18\x02 \x03(\tR\x0fpublicEndpoints\x12B\n" +
	"\tinstances\x18\n" +
	" \x03(\v2$.nebius.ai.v1.EndpointInstanceStatusR\tinstances\x128\n" +
	"\x05state\x18\x14 \x01(\x0e2\".nebius.ai.v1.EndpointStatus.StateR\x05state\x12G\n" +
	"\rstate_details\x18\x15 \x01(\v2\".nebius.ai.v1.EndpointStateDetailsR\fstateDetails\"\x7f\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fPROVISIONING\x10\x01\x12\f\n" +
	"\bSTARTING\x10\x02\x12\v\n" +
	"\aRUNNING\x10\x03\x12\f\n" +
	"\bSTOPPING\x10\x04\x12\f\n" +
	"\bDELETING\x10\x05\x12\v\n" +
	"\aSTOPPED\x10\x06\x12\t\n" +
	"\x05ERROR\x10\b\"L\n" +
	"\x14EndpointStateDetails\x12\x1a\n" +
	"\x04code\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04code\x12\x18\n" +
	"\amessage\x18\x02 \x01(\tR\amessage\"\xd9\x03\n" +
	"\x16EndpointInstanceStatus\x12H\n" +
	"\x05state\x18\x01 \x01(\x0e2*.nebius.ai.v1.EndpointInstanceStatus.StateB\x06\xbaH\x03\xc8\x01\x01R\x05state\x12D\n" +
	"\x13compute_instance_id\x18\n" +
	" \x01(\tB\x14\xe2J\x11\n" +
	"\x0fcomputeinstanceR\x11computeInstanceId\x12e\n" +
	"\x16compute_instance_state\x18\v \x01(\x0e2/.nebius.compute.v1.InstanceStatus.InstanceStateR\x14computeInstanceState\x12\x1d\n" +
	"\n" +
	"private_ip\x18\f \x01(\tR\tprivateIp\x12\x1b\n" +
	"\tpublic_ip\x18\r \x01(\tR\bpublicIp\"\x8b\x01\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fPROVISIONING\x10\x01\x12\f\n" +
	"\bSTARTING\x10\x02\x12\v\n" +
	"\aRUNNING\x10\x03\x12\f\n" +
	"\bSTOPPING\x10\x04\x12\f\n" +
	"\bDELETING\x10\x05\x12\v\n" +
	"\aSTOPPED\x10\x06\x12\n" +
	"\n" +
	"\x06FAILED\x10\a\x12\t\n" +
	"\x05ERROR\x10\bBR\n" +
	"\x13ai.nebius.pub.ai.v1B\rEndpointProtoP\x01Z*github.com/nebius/gosdk/proto/nebius/ai/v1b\x06proto3"

var (
	file_nebius_ai_v1_endpoint_proto_rawDescOnce sync.Once
	file_nebius_ai_v1_endpoint_proto_rawDescData []byte
)

func file_nebius_ai_v1_endpoint_proto_rawDescGZIP() []byte {
	file_nebius_ai_v1_endpoint_proto_rawDescOnce.Do(func() {
		file_nebius_ai_v1_endpoint_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_nebius_ai_v1_endpoint_proto_rawDesc), len(file_nebius_ai_v1_endpoint_proto_rawDesc)))
	})
	return file_nebius_ai_v1_endpoint_proto_rawDescData
}

var file_nebius_ai_v1_endpoint_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_nebius_ai_v1_endpoint_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_nebius_ai_v1_endpoint_proto_goTypes = []any{
	(EndpointSpec_Port_Protocol)(0),          // 0: nebius.ai.v1.EndpointSpec.Port.Protocol
	(EndpointSpec_VolumeMount_Mode)(0),       // 1: nebius.ai.v1.EndpointSpec.VolumeMount.Mode
	(EndpointStatus_State)(0),                // 2: nebius.ai.v1.EndpointStatus.State
	(EndpointInstanceStatus_State)(0),        // 3: nebius.ai.v1.EndpointInstanceStatus.State
	(*Endpoint)(nil),                         // 4: nebius.ai.v1.Endpoint
	(*EndpointSpec)(nil),                     // 5: nebius.ai.v1.EndpointSpec
	(*EndpointStatus)(nil),                   // 6: nebius.ai.v1.EndpointStatus
	(*EndpointStateDetails)(nil),             // 7: nebius.ai.v1.EndpointStateDetails
	(*EndpointInstanceStatus)(nil),           // 8: nebius.ai.v1.EndpointInstanceStatus
	(*EndpointSpec_EnvironmentVariable)(nil), // 9: nebius.ai.v1.EndpointSpec.EnvironmentVariable
	(*EndpointSpec_Port)(nil),                // 10: nebius.ai.v1.EndpointSpec.Port
	(*EndpointSpec_VolumeMount)(nil),         // 11: nebius.ai.v1.EndpointSpec.VolumeMount
	(*EndpointSpec_DiskSpec)(nil),            // 12: nebius.ai.v1.EndpointSpec.DiskSpec
	(*EndpointSpec_RegistryCredentials)(nil), // 13: nebius.ai.v1.EndpointSpec.RegistryCredentials
	(*v1.ResourceMetadata)(nil),              // 14: nebius.common.v1.ResourceMetadata
	(v11.InstanceStatus_InstanceState)(0),    // 15: nebius.compute.v1.InstanceStatus.InstanceState
	(v11.DiskSpec_DiskType)(0),               // 16: nebius.compute.v1.DiskSpec.DiskType
}
var file_nebius_ai_v1_endpoint_proto_depIdxs = []int32{
	14, // 0: nebius.ai.v1.Endpoint.metadata:type_name -> nebius.common.v1.ResourceMetadata
	5,  // 1: nebius.ai.v1.Endpoint.spec:type_name -> nebius.ai.v1.EndpointSpec
	6,  // 2: nebius.ai.v1.Endpoint.status:type_name -> nebius.ai.v1.EndpointStatus
	9,  // 3: nebius.ai.v1.EndpointSpec.environment_variables:type_name -> nebius.ai.v1.EndpointSpec.EnvironmentVariable
	10, // 4: nebius.ai.v1.EndpointSpec.ports:type_name -> nebius.ai.v1.EndpointSpec.Port
	11, // 5: nebius.ai.v1.EndpointSpec.volumes:type_name -> nebius.ai.v1.EndpointSpec.VolumeMount
	13, // 6: nebius.ai.v1.EndpointSpec.registry_credentials:type_name -> nebius.ai.v1.EndpointSpec.RegistryCredentials
	12, // 7: nebius.ai.v1.EndpointSpec.disk:type_name -> nebius.ai.v1.EndpointSpec.DiskSpec
	8,  // 8: nebius.ai.v1.EndpointStatus.instances:type_name -> nebius.ai.v1.EndpointInstanceStatus
	2,  // 9: nebius.ai.v1.EndpointStatus.state:type_name -> nebius.ai.v1.EndpointStatus.State
	7,  // 10: nebius.ai.v1.EndpointStatus.state_details:type_name -> nebius.ai.v1.EndpointStateDetails
	3,  // 11: nebius.ai.v1.EndpointInstanceStatus.state:type_name -> nebius.ai.v1.EndpointInstanceStatus.State
	15, // 12: nebius.ai.v1.EndpointInstanceStatus.compute_instance_state:type_name -> nebius.compute.v1.InstanceStatus.InstanceState
	0,  // 13: nebius.ai.v1.EndpointSpec.Port.protocol:type_name -> nebius.ai.v1.EndpointSpec.Port.Protocol
	1,  // 14: nebius.ai.v1.EndpointSpec.VolumeMount.mode:type_name -> nebius.ai.v1.EndpointSpec.VolumeMount.Mode
	16, // 15: nebius.ai.v1.EndpointSpec.DiskSpec.type:type_name -> nebius.compute.v1.DiskSpec.DiskType
	16, // [16:16] is the sub-list for method output_type
	16, // [16:16] is the sub-list for method input_type
	16, // [16:16] is the sub-list for extension type_name
	16, // [16:16] is the sub-list for extension extendee
	0,  // [0:16] is the sub-list for field type_name
}

func init() { file_nebius_ai_v1_endpoint_proto_init() }
func file_nebius_ai_v1_endpoint_proto_init() {
	if File_nebius_ai_v1_endpoint_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_nebius_ai_v1_endpoint_proto_rawDesc), len(file_nebius_ai_v1_endpoint_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_nebius_ai_v1_endpoint_proto_goTypes,
		DependencyIndexes: file_nebius_ai_v1_endpoint_proto_depIdxs,
		EnumInfos:         file_nebius_ai_v1_endpoint_proto_enumTypes,
		MessageInfos:      file_nebius_ai_v1_endpoint_proto_msgTypes,
	}.Build()
	File_nebius_ai_v1_endpoint_proto = out.File
	file_nebius_ai_v1_endpoint_proto_goTypes = nil
	file_nebius_ai_v1_endpoint_proto_depIdxs = nil
}

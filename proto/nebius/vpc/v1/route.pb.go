// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.28.3
// source: nebius/vpc/v1/route.proto

package v1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	_ "github.com/nebius/gosdk/proto/nebius"
	v1 "github.com/nebius/gosdk/proto/nebius/common/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RouteStatus_State int32

const (
	// The state is unknown or not yet set.
	RouteStatus_STATE_UNSPECIFIED RouteStatus_State = 0
	// The route is configured and operational.
	RouteStatus_READY RouteStatus_State = 10
)

// Enum value maps for RouteStatus_State.
var (
	RouteStatus_State_name = map[int32]string{
		0:  "STATE_UNSPECIFIED",
		10: "READY",
	}
	RouteStatus_State_value = map[string]int32{
		"STATE_UNSPECIFIED": 0,
		"READY":             10,
	}
)

func (x RouteStatus_State) Enum() *RouteStatus_State {
	p := new(RouteStatus_State)
	*p = x
	return p
}

func (x RouteStatus_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RouteStatus_State) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_vpc_v1_route_proto_enumTypes[0].Descriptor()
}

func (RouteStatus_State) Type() protoreflect.EnumType {
	return &file_nebius_vpc_v1_route_proto_enumTypes[0]
}

func (x RouteStatus_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RouteStatus_State.Descriptor instead.
func (RouteStatus_State) EnumDescriptor() ([]byte, []int) {
	return file_nebius_vpc_v1_route_proto_rawDescGZIP(), []int{5, 0}
}

// Routes determine how network traffic is directed within a VPC network,
// specifying the path that traffic should take based on destination addresses.
type Route struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// `metadata.parent_id` represents the RouteTable.
	Metadata *v1.ResourceMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// Specification of the route's configuration.
	Spec *RouteSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	// Current status of the route.
	Status        *RouteStatus `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Route) Reset() {
	*x = Route{}
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Route) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Route) ProtoMessage() {}

func (x *Route) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Route.ProtoReflect.Descriptor instead.
func (*Route) Descriptor() ([]byte, []int) {
	return file_nebius_vpc_v1_route_proto_rawDescGZIP(), []int{0}
}

func (x *Route) GetMetadata() *v1.ResourceMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Route) GetSpec() *RouteSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Route) GetStatus() *RouteStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type RouteSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional description of the route.
	Description string `protobuf:"bytes,1,opt,name=description,proto3" json:"description,omitempty"`
	// Destination for the route.
	// Each destination CIDR must be unique within a route table.
	// When multiple routes match a destination IP, the route with the longest
	// matching prefix (most specific match) is selected.
	Destination *DestinationMatch `protobuf:"bytes,2,opt,name=destination,proto3" json:"destination,omitempty"`
	// Next hop configuration specifying where to send matching traffic.
	NextHop       *NextHop `protobuf:"bytes,3,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteSpec) Reset() {
	*x = RouteSpec{}
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteSpec) ProtoMessage() {}

func (x *RouteSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteSpec.ProtoReflect.Descriptor instead.
func (*RouteSpec) Descriptor() ([]byte, []int) {
	return file_nebius_vpc_v1_route_proto_rawDescGZIP(), []int{1}
}

func (x *RouteSpec) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *RouteSpec) GetDestination() *DestinationMatch {
	if x != nil {
		return x.Destination
	}
	return nil
}

func (x *RouteSpec) GetNextHop() *NextHop {
	if x != nil {
		return x.NextHop
	}
	return nil
}

type DestinationMatch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Destination CIDR block in IPv4 format (e.g., "0.0.0.0/0" for default route, "192.168.100.0/24" for specific subnet).
	// The CIDR notation specifies the range of IP addresses that this route will match.
	// Must be unique within a route table.
	Cidr          string `protobuf:"bytes,1,opt,name=cidr,proto3" json:"cidr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DestinationMatch) Reset() {
	*x = DestinationMatch{}
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DestinationMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DestinationMatch) ProtoMessage() {}

func (x *DestinationMatch) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DestinationMatch.ProtoReflect.Descriptor instead.
func (*DestinationMatch) Descriptor() ([]byte, []int) {
	return file_nebius_vpc_v1_route_proto_rawDescGZIP(), []int{2}
}

func (x *DestinationMatch) GetCidr() string {
	if x != nil {
		return x.Cidr
	}
	return ""
}

type NextHop struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Configuration for the next hop, which must be one of the following options.
	//
	// Types that are valid to be assigned to NextHop:
	//
	//	*NextHop_Allocation
	//	*NextHop_DefaultEgressGateway
	NextHop       isNextHop_NextHop `protobuf_oneof:"next_hop"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NextHop) Reset() {
	*x = NextHop{}
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NextHop) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NextHop) ProtoMessage() {}

func (x *NextHop) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NextHop.ProtoReflect.Descriptor instead.
func (*NextHop) Descriptor() ([]byte, []int) {
	return file_nebius_vpc_v1_route_proto_rawDescGZIP(), []int{3}
}

func (x *NextHop) GetNextHop() isNextHop_NextHop {
	if x != nil {
		return x.NextHop
	}
	return nil
}

func (x *NextHop) GetAllocation() *AllocationNextHop {
	if x != nil {
		if x, ok := x.NextHop.(*NextHop_Allocation); ok {
			return x.Allocation
		}
	}
	return nil
}

func (x *NextHop) GetDefaultEgressGateway() bool {
	if x != nil {
		if x, ok := x.NextHop.(*NextHop_DefaultEgressGateway); ok {
			return x.DefaultEgressGateway
		}
	}
	return false
}

type isNextHop_NextHop interface {
	isNextHop_NextHop()
}

type NextHop_Allocation struct {
	// Forward traffic to a specific IP allocation (/32 address only).
	// The allocation must be from the same network as the route table.
	// The allocation must be assigned to either a Compute instance or a Load Balancer.
	// Warning: If the allocation exists but is not assigned to any resource,
	// traffic will be forwarded to a "black hole" and dropped.
	Allocation *AllocationNextHop `protobuf:"bytes,1,opt,name=allocation,proto3,oneof"`
}

type NextHop_DefaultEgressGateway struct {
	// Use the default egress gateway for outbound traffic.
	// Note: For VMs with public addresses (Floating IPs/FIPs), the FIP-specific route
	// takes precedence over this default egress gateway route.
	DefaultEgressGateway bool `protobuf:"varint,2,opt,name=default_egress_gateway,json=defaultEgressGateway,proto3,oneof"`
}

func (*NextHop_Allocation) isNextHop_NextHop() {}

func (*NextHop_DefaultEgressGateway) isNextHop_NextHop() {}

// AllocationNextHop specifies an IP allocation as the next hop.
type AllocationNextHop struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID of the IP allocation to use as the next hop.
	Id            string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AllocationNextHop) Reset() {
	*x = AllocationNextHop{}
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationNextHop) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationNextHop) ProtoMessage() {}

func (x *AllocationNextHop) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationNextHop.ProtoReflect.Descriptor instead.
func (*AllocationNextHop) Descriptor() ([]byte, []int) {
	return file_nebius_vpc_v1_route_proto_rawDescGZIP(), []int{4}
}

func (x *AllocationNextHop) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type RouteStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current state of the route.
	State RouteStatus_State `protobuf:"varint,1,opt,name=state,proto3,enum=nebius.vpc.v1.RouteStatus_State" json:"state,omitempty"`
	// Detailed status of the next hop configuration.
	NextHop       *NextHopState `protobuf:"bytes,2,opt,name=next_hop,json=nextHop,proto3" json:"next_hop,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RouteStatus) Reset() {
	*x = RouteStatus{}
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RouteStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RouteStatus) ProtoMessage() {}

func (x *RouteStatus) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RouteStatus.ProtoReflect.Descriptor instead.
func (*RouteStatus) Descriptor() ([]byte, []int) {
	return file_nebius_vpc_v1_route_proto_rawDescGZIP(), []int{5}
}

func (x *RouteStatus) GetState() RouteStatus_State {
	if x != nil {
		return x.State
	}
	return RouteStatus_STATE_UNSPECIFIED
}

func (x *RouteStatus) GetNextHop() *NextHopState {
	if x != nil {
		return x.NextHop
	}
	return nil
}

type NextHopState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current state of the next hop configuration.
	//
	// Types that are valid to be assigned to NextHop:
	//
	//	*NextHopState_Allocation
	//	*NextHopState_DefaultEgressGateway
	NextHop       isNextHopState_NextHop `protobuf_oneof:"next_hop"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NextHopState) Reset() {
	*x = NextHopState{}
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NextHopState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NextHopState) ProtoMessage() {}

func (x *NextHopState) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NextHopState.ProtoReflect.Descriptor instead.
func (*NextHopState) Descriptor() ([]byte, []int) {
	return file_nebius_vpc_v1_route_proto_rawDescGZIP(), []int{6}
}

func (x *NextHopState) GetNextHop() isNextHopState_NextHop {
	if x != nil {
		return x.NextHop
	}
	return nil
}

func (x *NextHopState) GetAllocation() *AllocationNextHopState {
	if x != nil {
		if x, ok := x.NextHop.(*NextHopState_Allocation); ok {
			return x.Allocation
		}
	}
	return nil
}

func (x *NextHopState) GetDefaultEgressGateway() *DefaultEgressGatewayState {
	if x != nil {
		if x, ok := x.NextHop.(*NextHopState_DefaultEgressGateway); ok {
			return x.DefaultEgressGateway
		}
	}
	return nil
}

type isNextHopState_NextHop interface {
	isNextHopState_NextHop()
}

type NextHopState_Allocation struct {
	// Status of an allocation-based next hop.
	Allocation *AllocationNextHopState `protobuf:"bytes,1,opt,name=allocation,proto3,oneof"`
}

type NextHopState_DefaultEgressGateway struct {
	// Status of the default egress gateway configuration.
	DefaultEgressGateway *DefaultEgressGatewayState `protobuf:"bytes,2,opt,name=default_egress_gateway,json=defaultEgressGateway,proto3,oneof"`
}

func (*NextHopState_Allocation) isNextHopState_NextHop() {}

func (*NextHopState_DefaultEgressGateway) isNextHopState_NextHop() {}

type AllocationNextHopState struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The CIDR of the allocation being used as the next hop.
	Cidr          string `protobuf:"bytes,1,opt,name=cidr,proto3" json:"cidr,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AllocationNextHopState) Reset() {
	*x = AllocationNextHopState{}
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AllocationNextHopState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AllocationNextHopState) ProtoMessage() {}

func (x *AllocationNextHopState) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AllocationNextHopState.ProtoReflect.Descriptor instead.
func (*AllocationNextHopState) Descriptor() ([]byte, []int) {
	return file_nebius_vpc_v1_route_proto_rawDescGZIP(), []int{7}
}

func (x *AllocationNextHopState) GetCidr() string {
	if x != nil {
		return x.Cidr
	}
	return ""
}

type DefaultEgressGatewayState struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DefaultEgressGatewayState) Reset() {
	*x = DefaultEgressGatewayState{}
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DefaultEgressGatewayState) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DefaultEgressGatewayState) ProtoMessage() {}

func (x *DefaultEgressGatewayState) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_vpc_v1_route_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DefaultEgressGatewayState.ProtoReflect.Descriptor instead.
func (*DefaultEgressGatewayState) Descriptor() ([]byte, []int) {
	return file_nebius_vpc_v1_route_proto_rawDescGZIP(), []int{8}
}

var File_nebius_vpc_v1_route_proto protoreflect.FileDescriptor

const file_nebius_vpc_v1_route_proto_rawDesc = "" +
	"\n" +
	"\x19nebius/vpc/v1/route.proto\x12\rnebius.vpc.v1\x1a\x1bbuf/validate/validate.proto\x1a\x1fnebius/common/v1/metadata.proto\x1a\x18nebius/annotations.proto\"\xa9\x01\n" +
	"\x05Route\x12>\n" +
	"\bmetadata\x18\x01 \x01(\v2\".nebius.common.v1.ResourceMetadataR\bmetadata\x12,\n" +
	"\x04spec\x18\x02 \x01(\v2\x18.nebius.vpc.v1.RouteSpecR\x04spec\x122\n" +
	"\x06status\x18\x03 \x01(\v2\x1a.nebius.vpc.v1.RouteStatusR\x06status\"\xbb\x01\n" +
	"\tRouteSpec\x12 \n" +
	"\vdescription\x18\x01 \x01(\tR\vdescription\x12M\n" +
	"\vdestination\x18\x02 \x01(\v2\x1f.nebius.vpc.v1.DestinationMatchB\n" +
	"\xbaH\x03\xc8\x01\x01\xbaJ\x01\x02R\vdestination\x12=\n" +
	"\bnext_hop\x18\x03 \x01(\v2\x16.nebius.vpc.v1.NextHopB\n" +
	"\xbaH\x03\xc8\x01\x01\xbaJ\x01\x02R\anextHop\"\xd4\x01\n" +
	"\x10DestinationMatch\x12\xbf\x01\n" +
	"\x04cidr\x18\x01 \x01(\tB\xaa\x01\xbaH\xa2\x01\xba\x01\x9b\x01\n" +
	"\x11string.valid_cidr\x123destination.cidr must be a valid and specified CIDR\x1aQthis.matches('^([0-9]{1,3}\\\\.){3}[0-9]{1,3}/[0-9]+$') && this.isIpPrefix(4, true)\xc8\x01\x01\xbaJ\x01\x02R\x04cidr\"\x98\x01\n" +
	"\aNextHop\x12B\n" +
	"\n" +
	"allocation\x18\x01 \x01(\v2 .nebius.vpc.v1.AllocationNextHopH\x00R\n" +
	"allocation\x126\n" +
	"\x16default_egress_gateway\x18\x02 \x01(\bH\x00R\x14defaultEgressGatewayB\x11\n" +
	"\bnext_hop\x12\x05\xbaH\x02\b\x01\"+\n" +
	"\x11AllocationNextHop\x12\x16\n" +
	"\x02id\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x02id\"\xa8\x01\n" +
	"\vRouteStatus\x126\n" +
	"\x05state\x18\x01 \x01(\x0e2 .nebius.vpc.v1.RouteStatus.StateR\x05state\x126\n" +
	"\bnext_hop\x18\x02 \x01(\v2\x1b.nebius.vpc.v1.NextHopStateR\anextHop\")\n" +
	"\x05State\x12\x15\n" +
	"\x11STATE_UNSPECIFIED\x10\x00\x12\t\n" +
	"\x05READY\x10\n" +
	"\"\xc5\x01\n" +
	"\fNextHopState\x12G\n" +
	"\n" +
	"allocation\x18\x01 \x01(\v2%.nebius.vpc.v1.AllocationNextHopStateH\x00R\n" +
	"allocation\x12`\n" +
	"\x16default_egress_gateway\x18\x02 \x01(\v2(.nebius.vpc.v1.DefaultEgressGatewayStateH\x00R\x14defaultEgressGatewayB\n" +
	"\n" +
	"\bnext_hop\",\n" +
	"\x16AllocationNextHopState\x12\x12\n" +
	"\x04cidr\x18\x01 \x01(\tR\x04cidr\"\x1b\n" +
	"\x19DefaultEgressGatewayStateBQ\n" +
	"\x14ai.nebius.pub.vpc.v1B\n" +
	"RouteProtoP\x01Z+github.com/nebius/gosdk/proto/nebius/vpc/v1b\x06proto3"

var (
	file_nebius_vpc_v1_route_proto_rawDescOnce sync.Once
	file_nebius_vpc_v1_route_proto_rawDescData []byte
)

func file_nebius_vpc_v1_route_proto_rawDescGZIP() []byte {
	file_nebius_vpc_v1_route_proto_rawDescOnce.Do(func() {
		file_nebius_vpc_v1_route_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_nebius_vpc_v1_route_proto_rawDesc), len(file_nebius_vpc_v1_route_proto_rawDesc)))
	})
	return file_nebius_vpc_v1_route_proto_rawDescData
}

var file_nebius_vpc_v1_route_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_nebius_vpc_v1_route_proto_msgTypes = make([]protoimpl.MessageInfo, 9)
var file_nebius_vpc_v1_route_proto_goTypes = []any{
	(RouteStatus_State)(0),            // 0: nebius.vpc.v1.RouteStatus.State
	(*Route)(nil),                     // 1: nebius.vpc.v1.Route
	(*RouteSpec)(nil),                 // 2: nebius.vpc.v1.RouteSpec
	(*DestinationMatch)(nil),          // 3: nebius.vpc.v1.DestinationMatch
	(*NextHop)(nil),                   // 4: nebius.vpc.v1.NextHop
	(*AllocationNextHop)(nil),         // 5: nebius.vpc.v1.AllocationNextHop
	(*RouteStatus)(nil),               // 6: nebius.vpc.v1.RouteStatus
	(*NextHopState)(nil),              // 7: nebius.vpc.v1.NextHopState
	(*AllocationNextHopState)(nil),    // 8: nebius.vpc.v1.AllocationNextHopState
	(*DefaultEgressGatewayState)(nil), // 9: nebius.vpc.v1.DefaultEgressGatewayState
	(*v1.ResourceMetadata)(nil),       // 10: nebius.common.v1.ResourceMetadata
}
var file_nebius_vpc_v1_route_proto_depIdxs = []int32{
	10, // 0: nebius.vpc.v1.Route.metadata:type_name -> nebius.common.v1.ResourceMetadata
	2,  // 1: nebius.vpc.v1.Route.spec:type_name -> nebius.vpc.v1.RouteSpec
	6,  // 2: nebius.vpc.v1.Route.status:type_name -> nebius.vpc.v1.RouteStatus
	3,  // 3: nebius.vpc.v1.RouteSpec.destination:type_name -> nebius.vpc.v1.DestinationMatch
	4,  // 4: nebius.vpc.v1.RouteSpec.next_hop:type_name -> nebius.vpc.v1.NextHop
	5,  // 5: nebius.vpc.v1.NextHop.allocation:type_name -> nebius.vpc.v1.AllocationNextHop
	0,  // 6: nebius.vpc.v1.RouteStatus.state:type_name -> nebius.vpc.v1.RouteStatus.State
	7,  // 7: nebius.vpc.v1.RouteStatus.next_hop:type_name -> nebius.vpc.v1.NextHopState
	8,  // 8: nebius.vpc.v1.NextHopState.allocation:type_name -> nebius.vpc.v1.AllocationNextHopState
	9,  // 9: nebius.vpc.v1.NextHopState.default_egress_gateway:type_name -> nebius.vpc.v1.DefaultEgressGatewayState
	10, // [10:10] is the sub-list for method output_type
	10, // [10:10] is the sub-list for method input_type
	10, // [10:10] is the sub-list for extension type_name
	10, // [10:10] is the sub-list for extension extendee
	0,  // [0:10] is the sub-list for field type_name
}

func init() { file_nebius_vpc_v1_route_proto_init() }
func file_nebius_vpc_v1_route_proto_init() {
	if File_nebius_vpc_v1_route_proto != nil {
		return
	}
	file_nebius_vpc_v1_route_proto_msgTypes[3].OneofWrappers = []any{
		(*NextHop_Allocation)(nil),
		(*NextHop_DefaultEgressGateway)(nil),
	}
	file_nebius_vpc_v1_route_proto_msgTypes[6].OneofWrappers = []any{
		(*NextHopState_Allocation)(nil),
		(*NextHopState_DefaultEgressGateway)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_nebius_vpc_v1_route_proto_rawDesc), len(file_nebius_vpc_v1_route_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   9,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_nebius_vpc_v1_route_proto_goTypes,
		DependencyIndexes: file_nebius_vpc_v1_route_proto_depIdxs,
		EnumInfos:         file_nebius_vpc_v1_route_proto_enumTypes,
		MessageInfos:      file_nebius_vpc_v1_route_proto_msgTypes,
	}.Build()
	File_nebius_vpc_v1_route_proto = out.File
	file_nebius_vpc_v1_route_proto_goTypes = nil
	file_nebius_vpc_v1_route_proto_depIdxs = nil
}

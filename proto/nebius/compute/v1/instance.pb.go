// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.28.3
// source: nebius/compute/v1/instance.proto

package v1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	_ "github.com/nebius/gosdk/proto/nebius"
	v1 "github.com/nebius/gosdk/proto/nebius/common/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type InstanceRecoveryPolicy int32

const (
	InstanceRecoveryPolicy_RECOVER InstanceRecoveryPolicy = 0
	InstanceRecoveryPolicy_FAIL    InstanceRecoveryPolicy = 1
)

// Enum value maps for InstanceRecoveryPolicy.
var (
	InstanceRecoveryPolicy_name = map[int32]string{
		0: "RECOVER",
		1: "FAIL",
	}
	InstanceRecoveryPolicy_value = map[string]int32{
		"RECOVER": 0,
		"FAIL":    1,
	}
)

func (x InstanceRecoveryPolicy) Enum() *InstanceRecoveryPolicy {
	p := new(InstanceRecoveryPolicy)
	*p = x
	return p
}

func (x InstanceRecoveryPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InstanceRecoveryPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_compute_v1_instance_proto_enumTypes[0].Descriptor()
}

func (InstanceRecoveryPolicy) Type() protoreflect.EnumType {
	return &file_nebius_compute_v1_instance_proto_enumTypes[0]
}

func (x InstanceRecoveryPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use InstanceRecoveryPolicy.Descriptor instead.
func (InstanceRecoveryPolicy) EnumDescriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{0}
}

type PreemptibleSpec_PreemptionPolicy int32

const (
	PreemptibleSpec_UNSPECIFIED PreemptibleSpec_PreemptionPolicy = 0
	PreemptibleSpec_STOP        PreemptibleSpec_PreemptionPolicy = 1
)

// Enum value maps for PreemptibleSpec_PreemptionPolicy.
var (
	PreemptibleSpec_PreemptionPolicy_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "STOP",
	}
	PreemptibleSpec_PreemptionPolicy_value = map[string]int32{
		"UNSPECIFIED": 0,
		"STOP":        1,
	}
)

func (x PreemptibleSpec_PreemptionPolicy) Enum() *PreemptibleSpec_PreemptionPolicy {
	p := new(PreemptibleSpec_PreemptionPolicy)
	*p = x
	return p
}

func (x PreemptibleSpec_PreemptionPolicy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PreemptibleSpec_PreemptionPolicy) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_compute_v1_instance_proto_enumTypes[1].Descriptor()
}

func (PreemptibleSpec_PreemptionPolicy) Type() protoreflect.EnumType {
	return &file_nebius_compute_v1_instance_proto_enumTypes[1]
}

func (x PreemptibleSpec_PreemptionPolicy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PreemptibleSpec_PreemptionPolicy.Descriptor instead.
func (PreemptibleSpec_PreemptionPolicy) EnumDescriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{2, 0}
}

type AttachedDiskSpec_AttachMode int32

const (
	AttachedDiskSpec_UNSPECIFIED AttachedDiskSpec_AttachMode = 0
	AttachedDiskSpec_READ_ONLY   AttachedDiskSpec_AttachMode = 1
	AttachedDiskSpec_READ_WRITE  AttachedDiskSpec_AttachMode = 2
)

// Enum value maps for AttachedDiskSpec_AttachMode.
var (
	AttachedDiskSpec_AttachMode_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "READ_ONLY",
		2: "READ_WRITE",
	}
	AttachedDiskSpec_AttachMode_value = map[string]int32{
		"UNSPECIFIED": 0,
		"READ_ONLY":   1,
		"READ_WRITE":  2,
	}
)

func (x AttachedDiskSpec_AttachMode) Enum() *AttachedDiskSpec_AttachMode {
	p := new(AttachedDiskSpec_AttachMode)
	*p = x
	return p
}

func (x AttachedDiskSpec_AttachMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AttachedDiskSpec_AttachMode) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_compute_v1_instance_proto_enumTypes[2].Descriptor()
}

func (AttachedDiskSpec_AttachMode) Type() protoreflect.EnumType {
	return &file_nebius_compute_v1_instance_proto_enumTypes[2]
}

func (x AttachedDiskSpec_AttachMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AttachedDiskSpec_AttachMode.Descriptor instead.
func (AttachedDiskSpec_AttachMode) EnumDescriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{5, 0}
}

type AttachedFilesystemSpec_AttachMode int32

const (
	AttachedFilesystemSpec_UNSPECIFIED AttachedFilesystemSpec_AttachMode = 0
	AttachedFilesystemSpec_READ_ONLY   AttachedFilesystemSpec_AttachMode = 1
	AttachedFilesystemSpec_READ_WRITE  AttachedFilesystemSpec_AttachMode = 2
)

// Enum value maps for AttachedFilesystemSpec_AttachMode.
var (
	AttachedFilesystemSpec_AttachMode_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "READ_ONLY",
		2: "READ_WRITE",
	}
	AttachedFilesystemSpec_AttachMode_value = map[string]int32{
		"UNSPECIFIED": 0,
		"READ_ONLY":   1,
		"READ_WRITE":  2,
	}
)

func (x AttachedFilesystemSpec_AttachMode) Enum() *AttachedFilesystemSpec_AttachMode {
	p := new(AttachedFilesystemSpec_AttachMode)
	*p = x
	return p
}

func (x AttachedFilesystemSpec_AttachMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (AttachedFilesystemSpec_AttachMode) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_compute_v1_instance_proto_enumTypes[3].Descriptor()
}

func (AttachedFilesystemSpec_AttachMode) Type() protoreflect.EnumType {
	return &file_nebius_compute_v1_instance_proto_enumTypes[3]
}

func (x AttachedFilesystemSpec_AttachMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use AttachedFilesystemSpec_AttachMode.Descriptor instead.
func (AttachedFilesystemSpec_AttachMode) EnumDescriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{8, 0}
}

type InstanceStatus_InstanceState int32

const (
	InstanceStatus_UNSPECIFIED InstanceStatus_InstanceState = 0
	InstanceStatus_CREATING    InstanceStatus_InstanceState = 1
	InstanceStatus_UPDATING    InstanceStatus_InstanceState = 2
	InstanceStatus_STARTING    InstanceStatus_InstanceState = 3
	InstanceStatus_RUNNING     InstanceStatus_InstanceState = 4
	InstanceStatus_STOPPING    InstanceStatus_InstanceState = 5
	InstanceStatus_STOPPED     InstanceStatus_InstanceState = 6
	InstanceStatus_DELETING    InstanceStatus_InstanceState = 7
	InstanceStatus_ERROR       InstanceStatus_InstanceState = 8
)

// Enum value maps for InstanceStatus_InstanceState.
var (
	InstanceStatus_InstanceState_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "CREATING",
		2: "UPDATING",
		3: "STARTING",
		4: "RUNNING",
		5: "STOPPING",
		6: "STOPPED",
		7: "DELETING",
		8: "ERROR",
	}
	InstanceStatus_InstanceState_value = map[string]int32{
		"UNSPECIFIED": 0,
		"CREATING":    1,
		"UPDATING":    2,
		"STARTING":    3,
		"RUNNING":     4,
		"STOPPING":    5,
		"STOPPED":     6,
		"DELETING":    7,
		"ERROR":       8,
	}
)

func (x InstanceStatus_InstanceState) Enum() *InstanceStatus_InstanceState {
	p := new(InstanceStatus_InstanceState)
	*p = x
	return p
}

func (x InstanceStatus_InstanceState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (InstanceStatus_InstanceState) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_compute_v1_instance_proto_enumTypes[4].Descriptor()
}

func (InstanceStatus_InstanceState) Type() protoreflect.EnumType {
	return &file_nebius_compute_v1_instance_proto_enumTypes[4]
}

func (x InstanceStatus_InstanceState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use InstanceStatus_InstanceState.Descriptor instead.
func (InstanceStatus_InstanceState) EnumDescriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{9, 0}
}

type ReservationPolicy_Policy int32

const (
	// 1) Will try to launch instance in any reservation_ids if provided.
	// 2) Will try to launch instance in any of the available capacity block.
	// 3) Will try to launch instance in PAYG if 1 & 2 are not satisfied.
	ReservationPolicy_AUTO ReservationPolicy_Policy = 0
	// The instance is launched only using on-demand (PAYG) capacity.
	// No attempt is made to find or use a Capacity Block.
	// It's an error to provide reservation_ids with policy = FORBID
	ReservationPolicy_FORBID ReservationPolicy_Policy = 1
	// 1) Will try to launch the instance in Capacity Blocks from reservation_ids if provided.
	// 2) If reservation_ids are not provided will try to launch instance in suitable & available Capacity Block.
	// 3) Fail otherwise.
	ReservationPolicy_STRICT ReservationPolicy_Policy = 2
)

// Enum value maps for ReservationPolicy_Policy.
var (
	ReservationPolicy_Policy_name = map[int32]string{
		0: "AUTO",
		1: "FORBID",
		2: "STRICT",
	}
	ReservationPolicy_Policy_value = map[string]int32{
		"AUTO":   0,
		"FORBID": 1,
		"STRICT": 2,
	}
)

func (x ReservationPolicy_Policy) Enum() *ReservationPolicy_Policy {
	p := new(ReservationPolicy_Policy)
	*p = x
	return p
}

func (x ReservationPolicy_Policy) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReservationPolicy_Policy) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_compute_v1_instance_proto_enumTypes[5].Descriptor()
}

func (ReservationPolicy_Policy) Type() protoreflect.EnumType {
	return &file_nebius_compute_v1_instance_proto_enumTypes[5]
}

func (x ReservationPolicy_Policy) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReservationPolicy_Policy.Descriptor instead.
func (ReservationPolicy_Policy) EnumDescriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{11, 0}
}

type Instance struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Metadata      *v1.ResourceMetadata   `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	Spec          *InstanceSpec          `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	Status        *InstanceStatus        `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Instance) Reset() {
	*x = Instance{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Instance) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Instance) ProtoMessage() {}

func (x *Instance) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Instance.ProtoReflect.Descriptor instead.
func (*Instance) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{0}
}

func (x *Instance) GetMetadata() *v1.ResourceMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Instance) GetSpec() *InstanceSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Instance) GetStatus() *InstanceStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

type InstanceSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique identifier of the service account associated with this instance.
	// For details, see https://docs.nebius.dev/en/iam/about-iam/concepts/service-accounts
	ServiceAccountId string `protobuf:"bytes,1,opt,name=service_account_id,json=serviceAccountId,proto3" json:"service_account_id,omitempty"`
	// Specification of compute resources allocated to the instance.
	// For details, see https://docs.nebius.com/compute/virtual-machines/types
	Resources *ResourcesSpec `protobuf:"bytes,2,opt,name=resources,proto3" json:"resources,omitempty"`
	// If you want to interconnect several instances in a GPU cluster via NVIDIA InfiniBand,
	// set the ID of an existing GPU cluster.
	// You can only add the VM to the cluster when creating the VM.
	// For details, see https://docs.nebius.com/compute/clusters/gpu
	GpuCluster *InstanceGpuClusterSpec `protobuf:"bytes,3,opt,name=gpu_cluster,json=gpuCluster,proto3" json:"gpu_cluster,omitempty"`
	// List of network interfaces attached to the instance.
	NetworkInterfaces []*NetworkInterfaceSpec `protobuf:"bytes,4,rep,name=network_interfaces,json=networkInterfaces,proto3" json:"network_interfaces,omitempty"`
	// Specified boot disk attached to the instance.
	BootDisk *AttachedDiskSpec `protobuf:"bytes,5,opt,name=boot_disk,json=bootDisk,proto3" json:"boot_disk,omitempty"`
	// List of additional data disks attached to the instance beyond the boot disk.
	SecondaryDisks []*AttachedDiskSpec `protobuf:"bytes,6,rep,name=secondary_disks,json=secondaryDisks,proto3" json:"secondary_disks,omitempty"`
	// List of Shared Filesystems attached to the instance.
	Filesystems []*AttachedFilesystemSpec `protobuf:"bytes,7,rep,name=filesystems,proto3" json:"filesystems,omitempty"`
	// Data in cloud-init format for customizing instance initialization.
	// For details, see https://docs.nebius.com/compute/virtual-machines/manage#user-data
	CloudInitUserData string `protobuf:"bytes,8,opt,name=cloud_init_user_data,json=cloudInitUserData,proto3" json:"cloud_init_user_data,omitempty"`
	// Indicates whether the instance should be stopped.
	Stopped bool `protobuf:"varint,13,opt,name=stopped,proto3" json:"stopped,omitempty"`
	// Recovery policy defines how the instance will be treated in case of a failure. Common source of failure is a host failure, but it can be any other failure.
	// Instance undergoing a guest shutdown (poweroff, etc.) will be subject to recovery policy, meaning that it could be restarted and billed accordingly. Stop instance via API or UI to stop it to avoid recovering.
	// If set to RECOVER, instance will be restarted, if possible. It could be restarted on the same host or on another host.
	// If set to FAIL, instance will be stopped and not restarted.
	RecoveryPolicy InstanceRecoveryPolicy `protobuf:"varint,15,opt,name=recovery_policy,json=recoveryPolicy,proto3,enum=nebius.compute.v1.InstanceRecoveryPolicy" json:"recovery_policy,omitempty"`
	// Include these parameters to create a Preemptible VM and omit them to create a Regular VM
	// For details, see https://docs.nebius.com/compute/virtual-machines/preemptible
	Preemptible *PreemptibleSpec `protobuf:"bytes,19,opt,name=preemptible,proto3" json:"preemptible,omitempty"`
	// Instance's hostname. Used to generate default DNS record in format `<hostname>.<network_id>.compute.internal.`
	// or `<instance_id>.<network_id>.compute.internal.` if hostname is not specified.
	Hostname          string             `protobuf:"bytes,20,opt,name=hostname,proto3" json:"hostname,omitempty"`
	ReservationPolicy *ReservationPolicy `protobuf:"bytes,23,opt,name=reservation_policy,json=reservationPolicy,proto3" json:"reservation_policy,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *InstanceSpec) Reset() {
	*x = InstanceSpec{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstanceSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstanceSpec) ProtoMessage() {}

func (x *InstanceSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstanceSpec.ProtoReflect.Descriptor instead.
func (*InstanceSpec) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{1}
}

func (x *InstanceSpec) GetServiceAccountId() string {
	if x != nil {
		return x.ServiceAccountId
	}
	return ""
}

func (x *InstanceSpec) GetResources() *ResourcesSpec {
	if x != nil {
		return x.Resources
	}
	return nil
}

func (x *InstanceSpec) GetGpuCluster() *InstanceGpuClusterSpec {
	if x != nil {
		return x.GpuCluster
	}
	return nil
}

func (x *InstanceSpec) GetNetworkInterfaces() []*NetworkInterfaceSpec {
	if x != nil {
		return x.NetworkInterfaces
	}
	return nil
}

func (x *InstanceSpec) GetBootDisk() *AttachedDiskSpec {
	if x != nil {
		return x.BootDisk
	}
	return nil
}

func (x *InstanceSpec) GetSecondaryDisks() []*AttachedDiskSpec {
	if x != nil {
		return x.SecondaryDisks
	}
	return nil
}

func (x *InstanceSpec) GetFilesystems() []*AttachedFilesystemSpec {
	if x != nil {
		return x.Filesystems
	}
	return nil
}

func (x *InstanceSpec) GetCloudInitUserData() string {
	if x != nil {
		return x.CloudInitUserData
	}
	return ""
}

func (x *InstanceSpec) GetStopped() bool {
	if x != nil {
		return x.Stopped
	}
	return false
}

func (x *InstanceSpec) GetRecoveryPolicy() InstanceRecoveryPolicy {
	if x != nil {
		return x.RecoveryPolicy
	}
	return InstanceRecoveryPolicy_RECOVER
}

func (x *InstanceSpec) GetPreemptible() *PreemptibleSpec {
	if x != nil {
		return x.Preemptible
	}
	return nil
}

func (x *InstanceSpec) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *InstanceSpec) GetReservationPolicy() *ReservationPolicy {
	if x != nil {
		return x.ReservationPolicy
	}
	return nil
}

type PreemptibleSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Specifies what happens when the VM is preempted. The only supported value is STOP:
	// Compute stops the VM without deleting or restarting it.
	OnPreemption PreemptibleSpec_PreemptionPolicy `protobuf:"varint,1,opt,name=on_preemption,json=onPreemption,proto3,enum=nebius.compute.v1.PreemptibleSpec_PreemptionPolicy" json:"on_preemption,omitempty"`
	// The value can range from 1 to 5, where 5 indicates the highest priority.
	// Affects the order in which Compute tries to preempt VMs, but does not guarantee the exact order.
	Priority      int32 `protobuf:"varint,2,opt,name=priority,proto3" json:"priority,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PreemptibleSpec) Reset() {
	*x = PreemptibleSpec{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PreemptibleSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PreemptibleSpec) ProtoMessage() {}

func (x *PreemptibleSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PreemptibleSpec.ProtoReflect.Descriptor instead.
func (*PreemptibleSpec) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{2}
}

func (x *PreemptibleSpec) GetOnPreemption() PreemptibleSpec_PreemptionPolicy {
	if x != nil {
		return x.OnPreemption
	}
	return PreemptibleSpec_UNSPECIFIED
}

func (x *PreemptibleSpec) GetPriority() int32 {
	if x != nil {
		return x.Priority
	}
	return 0
}

type ResourcesSpec struct {
	state    protoimpl.MessageState `protogen:"open.v1"`
	Platform string                 `protobuf:"bytes,1,opt,name=platform,proto3" json:"platform,omitempty"`
	// Types that are valid to be assigned to Size:
	//
	//	*ResourcesSpec_Preset
	Size          isResourcesSpec_Size `protobuf_oneof:"size"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResourcesSpec) Reset() {
	*x = ResourcesSpec{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResourcesSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResourcesSpec) ProtoMessage() {}

func (x *ResourcesSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResourcesSpec.ProtoReflect.Descriptor instead.
func (*ResourcesSpec) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{3}
}

func (x *ResourcesSpec) GetPlatform() string {
	if x != nil {
		return x.Platform
	}
	return ""
}

func (x *ResourcesSpec) GetSize() isResourcesSpec_Size {
	if x != nil {
		return x.Size
	}
	return nil
}

func (x *ResourcesSpec) GetPreset() string {
	if x != nil {
		if x, ok := x.Size.(*ResourcesSpec_Preset); ok {
			return x.Preset
		}
	}
	return ""
}

type isResourcesSpec_Size interface {
	isResourcesSpec_Size()
}

type ResourcesSpec_Preset struct {
	Preset string `protobuf:"bytes,2,opt,name=preset,proto3,oneof"`
}

func (*ResourcesSpec_Preset) isResourcesSpec_Size() {}

type InstanceGpuClusterSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If you want to interconnect several instances in a GPU cluster via NVIDIA InfiniBand,
	// set the ID of an existing GPU cluster.
	// You can only add the VM to the cluster when creating the VM.
	// For details, see https://docs.nebius.com/compute/clusters/gpu
	Id            string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstanceGpuClusterSpec) Reset() {
	*x = InstanceGpuClusterSpec{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstanceGpuClusterSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstanceGpuClusterSpec) ProtoMessage() {}

func (x *InstanceGpuClusterSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstanceGpuClusterSpec.ProtoReflect.Descriptor instead.
func (*InstanceGpuClusterSpec) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{4}
}

func (x *InstanceGpuClusterSpec) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type AttachedDiskSpec struct {
	state      protoimpl.MessageState      `protogen:"open.v1"`
	AttachMode AttachedDiskSpec_AttachMode `protobuf:"varint,1,opt,name=attach_mode,json=attachMode,proto3,enum=nebius.compute.v1.AttachedDiskSpec_AttachMode" json:"attach_mode,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*AttachedDiskSpec_ExistingDisk
	Type isAttachedDiskSpec_Type `protobuf_oneof:"type"`
	// Specifies the user-defined identifier, allowing to use '/dev/disk/by-id/virtio-{device_id}' as a device path in mount command.
	DeviceId      string `protobuf:"bytes,3,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttachedDiskSpec) Reset() {
	*x = AttachedDiskSpec{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttachedDiskSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachedDiskSpec) ProtoMessage() {}

func (x *AttachedDiskSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachedDiskSpec.ProtoReflect.Descriptor instead.
func (*AttachedDiskSpec) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{5}
}

func (x *AttachedDiskSpec) GetAttachMode() AttachedDiskSpec_AttachMode {
	if x != nil {
		return x.AttachMode
	}
	return AttachedDiskSpec_UNSPECIFIED
}

func (x *AttachedDiskSpec) GetType() isAttachedDiskSpec_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *AttachedDiskSpec) GetExistingDisk() *ExistingDisk {
	if x != nil {
		if x, ok := x.Type.(*AttachedDiskSpec_ExistingDisk); ok {
			return x.ExistingDisk
		}
	}
	return nil
}

func (x *AttachedDiskSpec) GetDeviceId() string {
	if x != nil {
		return x.DeviceId
	}
	return ""
}

type isAttachedDiskSpec_Type interface {
	isAttachedDiskSpec_Type()
}

type AttachedDiskSpec_ExistingDisk struct {
	ExistingDisk *ExistingDisk `protobuf:"bytes,2,opt,name=existing_disk,json=existingDisk,proto3,oneof"`
}

func (*AttachedDiskSpec_ExistingDisk) isAttachedDiskSpec_Type() {}

type ExistingDisk struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExistingDisk) Reset() {
	*x = ExistingDisk{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExistingDisk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExistingDisk) ProtoMessage() {}

func (x *ExistingDisk) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExistingDisk.ProtoReflect.Descriptor instead.
func (*ExistingDisk) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{6}
}

func (x *ExistingDisk) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type ExistingFilesystem struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExistingFilesystem) Reset() {
	*x = ExistingFilesystem{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExistingFilesystem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExistingFilesystem) ProtoMessage() {}

func (x *ExistingFilesystem) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExistingFilesystem.ProtoReflect.Descriptor instead.
func (*ExistingFilesystem) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{7}
}

func (x *ExistingFilesystem) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

type AttachedFilesystemSpec struct {
	state      protoimpl.MessageState            `protogen:"open.v1"`
	AttachMode AttachedFilesystemSpec_AttachMode `protobuf:"varint,1,opt,name=attach_mode,json=attachMode,proto3,enum=nebius.compute.v1.AttachedFilesystemSpec_AttachMode" json:"attach_mode,omitempty"`
	// Specifies the user-defined identifier, allowing to use it as a device in mount command.
	MountTag string `protobuf:"bytes,2,opt,name=mount_tag,json=mountTag,proto3" json:"mount_tag,omitempty"`
	// Types that are valid to be assigned to Type:
	//
	//	*AttachedFilesystemSpec_ExistingFilesystem
	Type          isAttachedFilesystemSpec_Type `protobuf_oneof:"type"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AttachedFilesystemSpec) Reset() {
	*x = AttachedFilesystemSpec{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AttachedFilesystemSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AttachedFilesystemSpec) ProtoMessage() {}

func (x *AttachedFilesystemSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AttachedFilesystemSpec.ProtoReflect.Descriptor instead.
func (*AttachedFilesystemSpec) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{8}
}

func (x *AttachedFilesystemSpec) GetAttachMode() AttachedFilesystemSpec_AttachMode {
	if x != nil {
		return x.AttachMode
	}
	return AttachedFilesystemSpec_UNSPECIFIED
}

func (x *AttachedFilesystemSpec) GetMountTag() string {
	if x != nil {
		return x.MountTag
	}
	return ""
}

func (x *AttachedFilesystemSpec) GetType() isAttachedFilesystemSpec_Type {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *AttachedFilesystemSpec) GetExistingFilesystem() *ExistingFilesystem {
	if x != nil {
		if x, ok := x.Type.(*AttachedFilesystemSpec_ExistingFilesystem); ok {
			return x.ExistingFilesystem
		}
	}
	return nil
}

type isAttachedFilesystemSpec_Type interface {
	isAttachedFilesystemSpec_Type()
}

type AttachedFilesystemSpec_ExistingFilesystem struct {
	ExistingFilesystem *ExistingFilesystem `protobuf:"bytes,3,opt,name=existing_filesystem,json=existingFilesystem,proto3,oneof"`
}

func (*AttachedFilesystemSpec_ExistingFilesystem) isAttachedFilesystemSpec_Type() {}

type InstanceStatus struct {
	state             protoimpl.MessageState       `protogen:"open.v1"`
	State             InstanceStatus_InstanceState `protobuf:"varint,1,opt,name=state,proto3,enum=nebius.compute.v1.InstanceStatus_InstanceState" json:"state,omitempty"`
	NetworkInterfaces []*NetworkInterfaceStatus    `protobuf:"bytes,2,rep,name=network_interfaces,json=networkInterfaces,proto3" json:"network_interfaces,omitempty"`
	// Indicates whether there is an ongoing operation
	Reconciling        bool   `protobuf:"varint,5,opt,name=reconciling,proto3" json:"reconciling,omitempty"`
	MaintenanceEventId string `protobuf:"bytes,7,opt,name=maintenance_event_id,json=maintenanceEventId,proto3" json:"maintenance_event_id,omitempty"`
	// Types that are valid to be assigned to GpuClusterTopology:
	//
	//	*InstanceStatus_InfinibandTopologyPath
	GpuClusterTopology isInstanceStatus_GpuClusterTopology `protobuf_oneof:"gpu_cluster_topology"`
	ReservationId      string                              `protobuf:"bytes,12,opt,name=reservation_id,json=reservationId,proto3" json:"reservation_id,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *InstanceStatus) Reset() {
	*x = InstanceStatus{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstanceStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstanceStatus) ProtoMessage() {}

func (x *InstanceStatus) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstanceStatus.ProtoReflect.Descriptor instead.
func (*InstanceStatus) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{9}
}

func (x *InstanceStatus) GetState() InstanceStatus_InstanceState {
	if x != nil {
		return x.State
	}
	return InstanceStatus_UNSPECIFIED
}

func (x *InstanceStatus) GetNetworkInterfaces() []*NetworkInterfaceStatus {
	if x != nil {
		return x.NetworkInterfaces
	}
	return nil
}

func (x *InstanceStatus) GetReconciling() bool {
	if x != nil {
		return x.Reconciling
	}
	return false
}

func (x *InstanceStatus) GetMaintenanceEventId() string {
	if x != nil {
		return x.MaintenanceEventId
	}
	return ""
}

func (x *InstanceStatus) GetGpuClusterTopology() isInstanceStatus_GpuClusterTopology {
	if x != nil {
		return x.GpuClusterTopology
	}
	return nil
}

func (x *InstanceStatus) GetInfinibandTopologyPath() *InstanceStatusInfinibandTopologyPath {
	if x != nil {
		if x, ok := x.GpuClusterTopology.(*InstanceStatus_InfinibandTopologyPath); ok {
			return x.InfinibandTopologyPath
		}
	}
	return nil
}

func (x *InstanceStatus) GetReservationId() string {
	if x != nil {
		return x.ReservationId
	}
	return ""
}

type isInstanceStatus_GpuClusterTopology interface {
	isInstanceStatus_GpuClusterTopology()
}

type InstanceStatus_InfinibandTopologyPath struct {
	InfinibandTopologyPath *InstanceStatusInfinibandTopologyPath `protobuf:"bytes,10,opt,name=infiniband_topology_path,json=infinibandTopologyPath,proto3,oneof"`
}

func (*InstanceStatus_InfinibandTopologyPath) isInstanceStatus_GpuClusterTopology() {}

type InstanceStatusInfinibandTopologyPath struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          []string               `protobuf:"bytes,1,rep,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *InstanceStatusInfinibandTopologyPath) Reset() {
	*x = InstanceStatusInfinibandTopologyPath{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *InstanceStatusInfinibandTopologyPath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*InstanceStatusInfinibandTopologyPath) ProtoMessage() {}

func (x *InstanceStatusInfinibandTopologyPath) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use InstanceStatusInfinibandTopologyPath.ProtoReflect.Descriptor instead.
func (*InstanceStatusInfinibandTopologyPath) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{10}
}

func (x *InstanceStatusInfinibandTopologyPath) GetPath() []string {
	if x != nil {
		return x.Path
	}
	return nil
}

type ReservationPolicy struct {
	state  protoimpl.MessageState   `protogen:"open.v1"`
	Policy ReservationPolicy_Policy `protobuf:"varint,1,opt,name=policy,proto3,enum=nebius.compute.v1.ReservationPolicy_Policy" json:"policy,omitempty"`
	// Capacity block groups, order matters
	ReservationIds []string `protobuf:"bytes,2,rep,name=reservation_ids,json=reservationIds,proto3" json:"reservation_ids,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ReservationPolicy) Reset() {
	*x = ReservationPolicy{}
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReservationPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReservationPolicy) ProtoMessage() {}

func (x *ReservationPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_compute_v1_instance_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReservationPolicy.ProtoReflect.Descriptor instead.
func (*ReservationPolicy) Descriptor() ([]byte, []int) {
	return file_nebius_compute_v1_instance_proto_rawDescGZIP(), []int{11}
}

func (x *ReservationPolicy) GetPolicy() ReservationPolicy_Policy {
	if x != nil {
		return x.Policy
	}
	return ReservationPolicy_AUTO
}

func (x *ReservationPolicy) GetReservationIds() []string {
	if x != nil {
		return x.ReservationIds
	}
	return nil
}

var File_nebius_compute_v1_instance_proto protoreflect.FileDescriptor

const file_nebius_compute_v1_instance_proto_rawDesc = "" +
	"\n" +
	" nebius/compute/v1/instance.proto\x12\x11nebius.compute.v1\x1a\x1bbuf/validate/validate.proto\x1a\x1fnebius/common/v1/metadata.proto\x1a\x18nebius/annotations.proto\x1a)nebius/compute/v1/network_interface.proto\"\xba\x01\n" +
	"\bInstance\x12>\n" +
	"\bmetadata\x18\x01 \x01(\v2\".nebius.common.v1.ResourceMetadataR\bmetadata\x123\n" +
	"\x04spec\x18\x02 \x01(\v2\x1f.nebius.compute.v1.InstanceSpecR\x04spec\x129\n" +
	"\x06status\x18\x03 \x01(\v2!.nebius.compute.v1.InstanceStatusR\x06status\"\x8e\b\n" +
	"\fInstanceSpec\x122\n" +
	"\x12service_account_id\x18\x01 \x01(\tB\x04\xbaJ\x01\x02R\x10serviceAccountId\x12F\n" +
	"\tresources\x18\x02 \x01(\v2 .nebius.compute.v1.ResourcesSpecB\x06\xbaH\x03\xc8\x01\x01R\tresources\x12P\n" +
	"\vgpu_cluster\x18\x03 \x01(\v2).nebius.compute.v1.InstanceGpuClusterSpecB\x04\xbaJ\x01\x02R\n" +
	"gpuCluster\x12c\n" +
	"\x12network_interfaces\x18\x04 \x03(\v2'.nebius.compute.v1.NetworkInterfaceSpecB\v\xbaH\b\xc8\x01\x01\x92\x01\x02\x10\bR\x11networkInterfaces\x12F\n" +
	"\tboot_disk\x18\x05 \x01(\v2#.nebius.compute.v1.AttachedDiskSpecB\x04\xbaJ\x01\x02R\bbootDisk\x12L\n" +
	"\x0fsecondary_disks\x18\x06 \x03(\v2#.nebius.compute.v1.AttachedDiskSpecR\x0esecondaryDisks\x12K\n" +
	"\vfilesystems\x18\a \x03(\v2).nebius.compute.v1.AttachedFilesystemSpecR\vfilesystems\x12=\n" +
	"\x14cloud_init_user_data\x18\b \x01(\tB\f\xbaH\x06r\x04\x18\x80\x80\x02\xc0J\x01R\x11cloudInitUserData\x12\x18\n" +
	"\astopped\x18\r \x01(\bR\astopped\x12X\n" +
	"\x0frecovery_policy\x18\x0f \x01(\x0e2).nebius.compute.v1.InstanceRecoveryPolicyB\x04\xbaJ\x01\x02R\x0erecoveryPolicy\x12J\n" +
	"\vpreemptible\x18\x13 \x01(\v2\".nebius.compute.v1.PreemptibleSpecB\x04\xbaJ\x01\x02R\vpreemptible\x12\x93\x01\n" +
	"\bhostname\x18\x14 \x01(\tBw\xbaHt\xba\x01q\n" +
	"\x0ehostname.valid\x12\x1evalue must be a valid hostname\x1a?this == '' || this.matches('^[a-z0-9][a-z0-9-]{0,61}[a-z0-9]$')R\bhostname\x12S\n" +
	"\x12reservation_policy\x18\x17 \x01(\v2$.nebius.compute.v1.ReservationPolicyR\x11reservationPolicy\"\xce\x01\n" +
	"\x0fPreemptibleSpec\x12d\n" +
	"\ron_preemption\x18\x01 \x01(\x0e23.nebius.compute.v1.PreemptibleSpec.PreemptionPolicyB\n" +
	"\xbaH\x03\xc8\x01\x01\xbaJ\x01\x02R\fonPreemption\x12&\n" +
	"\bpriority\x18\x02 \x01(\x05B\n" +
	"\xbaH\x03\xc8\x01\x01\xbaJ\x01\x02R\bpriority\"-\n" +
	"\x10PreemptionPolicy\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\b\n" +
	"\x04STOP\x10\x01\"`\n" +
	"\rResourcesSpec\x12&\n" +
	"\bplatform\x18\x01 \x01(\tB\n" +
	"\xbaH\x03\xc8\x01\x01\xbaJ\x01\x02R\bplatform\x12\x18\n" +
	"\x06preset\x18\x02 \x01(\tH\x00R\x06presetB\r\n" +
	"\x04size\x12\x05\xbaH\x02\b\x01\"(\n" +
	"\x16InstanceGpuClusterSpec\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\"\xa6\x02\n" +
	"\x10AttachedDiskSpec\x12W\n" +
	"\vattach_mode\x18\x01 \x01(\x0e2..nebius.compute.v1.AttachedDiskSpec.AttachModeB\x06\xbaH\x03\xc8\x01\x01R\n" +
	"attachMode\x12F\n" +
	"\rexisting_disk\x18\x02 \x01(\v2\x1f.nebius.compute.v1.ExistingDiskH\x00R\fexistingDisk\x12$\n" +
	"\tdevice_id\x18\x03 \x01(\tB\a\xbaH\x04r\x02\x18\x14R\bdeviceId\"<\n" +
	"\n" +
	"AttachMode\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\r\n" +
	"\tREAD_ONLY\x10\x01\x12\x0e\n" +
	"\n" +
	"READ_WRITE\x10\x02B\r\n" +
	"\x04type\x12\x05\xbaH\x02\b\x01\"&\n" +
	"\fExistingDisk\x12\x16\n" +
	"\x02id\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x02id\",\n" +
	"\x12ExistingFilesystem\x12\x16\n" +
	"\x02id\x18\x01 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x02id\"\xc7\x02\n" +
	"\x16AttachedFilesystemSpec\x12]\n" +
	"\vattach_mode\x18\x01 \x01(\x0e24.nebius.compute.v1.AttachedFilesystemSpec.AttachModeB\x06\xbaH\x03\xc8\x01\x01R\n" +
	"attachMode\x12'\n" +
	"\tmount_tag\x18\x02 \x01(\tB\n" +
	"\xbaH\a\xc8\x01\x01r\x02\x18%R\bmountTag\x12X\n" +
	"\x13existing_filesystem\x18\x03 \x01(\v2%.nebius.compute.v1.ExistingFilesystemH\x00R\x12existingFilesystem\"<\n" +
	"\n" +
	"AttachMode\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\r\n" +
	"\tREAD_ONLY\x10\x01\x12\x0e\n" +
	"\n" +
	"READ_WRITE\x10\x02B\r\n" +
	"\x04type\x12\x05\xbaH\x02\b\x01\"\xcd\x04\n" +
	"\x0eInstanceStatus\x12E\n" +
	"\x05state\x18\x01 \x01(\x0e2/.nebius.compute.v1.InstanceStatus.InstanceStateR\x05state\x12X\n" +
	"\x12network_interfaces\x18\x02 \x03(\v2).nebius.compute.v1.NetworkInterfaceStatusR\x11networkInterfaces\x12 \n" +
	"\vreconciling\x18\x05 \x01(\bR\vreconciling\x120\n" +
	"\x14maintenance_event_id\x18\a \x01(\tR\x12maintenanceEventId\x12s\n" +
	"\x18infiniband_topology_path\x18\n" +
	" \x01(\v27.nebius.compute.v1.InstanceStatusInfinibandTopologyPathH\x00R\x16infinibandTopologyPath\x12%\n" +
	"\x0ereservation_id\x18\f \x01(\tR\rreservationId\"\x8b\x01\n" +
	"\rInstanceState\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\f\n" +
	"\bCREATING\x10\x01\x12\f\n" +
	"\bUPDATING\x10\x02\x12\f\n" +
	"\bSTARTING\x10\x03\x12\v\n" +
	"\aRUNNING\x10\x04\x12\f\n" +
	"\bSTOPPING\x10\x05\x12\v\n" +
	"\aSTOPPED\x10\x06\x12\f\n" +
	"\bDELETING\x10\a\x12\t\n" +
	"\x05ERROR\x10\bB\x16\n" +
	"\x14gpu_cluster_topologyJ\x04\b\x06\x10\a\":\n" +
	"$InstanceStatusInfinibandTopologyPath\x12\x12\n" +
	"\x04path\x18\x01 \x03(\tR\x04path\"\xad\x01\n" +
	"\x11ReservationPolicy\x12C\n" +
	"\x06policy\x18\x01 \x01(\x0e2+.nebius.compute.v1.ReservationPolicy.PolicyR\x06policy\x12'\n" +
	"\x0freservation_ids\x18\x02 \x03(\tR\x0ereservationIds\"*\n" +
	"\x06Policy\x12\b\n" +
	"\x04AUTO\x10\x00\x12\n" +
	"\n" +
	"\x06FORBID\x10\x01\x12\n" +
	"\n" +
	"\x06STRICT\x10\x02*/\n" +
	"\x16InstanceRecoveryPolicy\x12\v\n" +
	"\aRECOVER\x10\x00\x12\b\n" +
	"\x04FAIL\x10\x01B\\\n" +
	"\x18ai.nebius.pub.compute.v1B\rInstanceProtoP\x01Z/github.com/nebius/gosdk/proto/nebius/compute/v1b\x06proto3"

var (
	file_nebius_compute_v1_instance_proto_rawDescOnce sync.Once
	file_nebius_compute_v1_instance_proto_rawDescData []byte
)

func file_nebius_compute_v1_instance_proto_rawDescGZIP() []byte {
	file_nebius_compute_v1_instance_proto_rawDescOnce.Do(func() {
		file_nebius_compute_v1_instance_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_nebius_compute_v1_instance_proto_rawDesc), len(file_nebius_compute_v1_instance_proto_rawDesc)))
	})
	return file_nebius_compute_v1_instance_proto_rawDescData
}

var file_nebius_compute_v1_instance_proto_enumTypes = make([]protoimpl.EnumInfo, 6)
var file_nebius_compute_v1_instance_proto_msgTypes = make([]protoimpl.MessageInfo, 12)
var file_nebius_compute_v1_instance_proto_goTypes = []any{
	(InstanceRecoveryPolicy)(0),                  // 0: nebius.compute.v1.InstanceRecoveryPolicy
	(PreemptibleSpec_PreemptionPolicy)(0),        // 1: nebius.compute.v1.PreemptibleSpec.PreemptionPolicy
	(AttachedDiskSpec_AttachMode)(0),             // 2: nebius.compute.v1.AttachedDiskSpec.AttachMode
	(AttachedFilesystemSpec_AttachMode)(0),       // 3: nebius.compute.v1.AttachedFilesystemSpec.AttachMode
	(InstanceStatus_InstanceState)(0),            // 4: nebius.compute.v1.InstanceStatus.InstanceState
	(ReservationPolicy_Policy)(0),                // 5: nebius.compute.v1.ReservationPolicy.Policy
	(*Instance)(nil),                             // 6: nebius.compute.v1.Instance
	(*InstanceSpec)(nil),                         // 7: nebius.compute.v1.InstanceSpec
	(*PreemptibleSpec)(nil),                      // 8: nebius.compute.v1.PreemptibleSpec
	(*ResourcesSpec)(nil),                        // 9: nebius.compute.v1.ResourcesSpec
	(*InstanceGpuClusterSpec)(nil),               // 10: nebius.compute.v1.InstanceGpuClusterSpec
	(*AttachedDiskSpec)(nil),                     // 11: nebius.compute.v1.AttachedDiskSpec
	(*ExistingDisk)(nil),                         // 12: nebius.compute.v1.ExistingDisk
	(*ExistingFilesystem)(nil),                   // 13: nebius.compute.v1.ExistingFilesystem
	(*AttachedFilesystemSpec)(nil),               // 14: nebius.compute.v1.AttachedFilesystemSpec
	(*InstanceStatus)(nil),                       // 15: nebius.compute.v1.InstanceStatus
	(*InstanceStatusInfinibandTopologyPath)(nil), // 16: nebius.compute.v1.InstanceStatusInfinibandTopologyPath
	(*ReservationPolicy)(nil),                    // 17: nebius.compute.v1.ReservationPolicy
	(*v1.ResourceMetadata)(nil),                  // 18: nebius.common.v1.ResourceMetadata
	(*NetworkInterfaceSpec)(nil),                 // 19: nebius.compute.v1.NetworkInterfaceSpec
	(*NetworkInterfaceStatus)(nil),               // 20: nebius.compute.v1.NetworkInterfaceStatus
}
var file_nebius_compute_v1_instance_proto_depIdxs = []int32{
	18, // 0: nebius.compute.v1.Instance.metadata:type_name -> nebius.common.v1.ResourceMetadata
	7,  // 1: nebius.compute.v1.Instance.spec:type_name -> nebius.compute.v1.InstanceSpec
	15, // 2: nebius.compute.v1.Instance.status:type_name -> nebius.compute.v1.InstanceStatus
	9,  // 3: nebius.compute.v1.InstanceSpec.resources:type_name -> nebius.compute.v1.ResourcesSpec
	10, // 4: nebius.compute.v1.InstanceSpec.gpu_cluster:type_name -> nebius.compute.v1.InstanceGpuClusterSpec
	19, // 5: nebius.compute.v1.InstanceSpec.network_interfaces:type_name -> nebius.compute.v1.NetworkInterfaceSpec
	11, // 6: nebius.compute.v1.InstanceSpec.boot_disk:type_name -> nebius.compute.v1.AttachedDiskSpec
	11, // 7: nebius.compute.v1.InstanceSpec.secondary_disks:type_name -> nebius.compute.v1.AttachedDiskSpec
	14, // 8: nebius.compute.v1.InstanceSpec.filesystems:type_name -> nebius.compute.v1.AttachedFilesystemSpec
	0,  // 9: nebius.compute.v1.InstanceSpec.recovery_policy:type_name -> nebius.compute.v1.InstanceRecoveryPolicy
	8,  // 10: nebius.compute.v1.InstanceSpec.preemptible:type_name -> nebius.compute.v1.PreemptibleSpec
	17, // 11: nebius.compute.v1.InstanceSpec.reservation_policy:type_name -> nebius.compute.v1.ReservationPolicy
	1,  // 12: nebius.compute.v1.PreemptibleSpec.on_preemption:type_name -> nebius.compute.v1.PreemptibleSpec.PreemptionPolicy
	2,  // 13: nebius.compute.v1.AttachedDiskSpec.attach_mode:type_name -> nebius.compute.v1.AttachedDiskSpec.AttachMode
	12, // 14: nebius.compute.v1.AttachedDiskSpec.existing_disk:type_name -> nebius.compute.v1.ExistingDisk
	3,  // 15: nebius.compute.v1.AttachedFilesystemSpec.attach_mode:type_name -> nebius.compute.v1.AttachedFilesystemSpec.AttachMode
	13, // 16: nebius.compute.v1.AttachedFilesystemSpec.existing_filesystem:type_name -> nebius.compute.v1.ExistingFilesystem
	4,  // 17: nebius.compute.v1.InstanceStatus.state:type_name -> nebius.compute.v1.InstanceStatus.InstanceState
	20, // 18: nebius.compute.v1.InstanceStatus.network_interfaces:type_name -> nebius.compute.v1.NetworkInterfaceStatus
	16, // 19: nebius.compute.v1.InstanceStatus.infiniband_topology_path:type_name -> nebius.compute.v1.InstanceStatusInfinibandTopologyPath
	5,  // 20: nebius.compute.v1.ReservationPolicy.policy:type_name -> nebius.compute.v1.ReservationPolicy.Policy
	21, // [21:21] is the sub-list for method output_type
	21, // [21:21] is the sub-list for method input_type
	21, // [21:21] is the sub-list for extension type_name
	21, // [21:21] is the sub-list for extension extendee
	0,  // [0:21] is the sub-list for field type_name
}

func init() { file_nebius_compute_v1_instance_proto_init() }
func file_nebius_compute_v1_instance_proto_init() {
	if File_nebius_compute_v1_instance_proto != nil {
		return
	}
	file_nebius_compute_v1_network_interface_proto_init()
	file_nebius_compute_v1_instance_proto_msgTypes[3].OneofWrappers = []any{
		(*ResourcesSpec_Preset)(nil),
	}
	file_nebius_compute_v1_instance_proto_msgTypes[5].OneofWrappers = []any{
		(*AttachedDiskSpec_ExistingDisk)(nil),
	}
	file_nebius_compute_v1_instance_proto_msgTypes[8].OneofWrappers = []any{
		(*AttachedFilesystemSpec_ExistingFilesystem)(nil),
	}
	file_nebius_compute_v1_instance_proto_msgTypes[9].OneofWrappers = []any{
		(*InstanceStatus_InfinibandTopologyPath)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_nebius_compute_v1_instance_proto_rawDesc), len(file_nebius_compute_v1_instance_proto_rawDesc)),
			NumEnums:      6,
			NumMessages:   12,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_nebius_compute_v1_instance_proto_goTypes,
		DependencyIndexes: file_nebius_compute_v1_instance_proto_depIdxs,
		EnumInfos:         file_nebius_compute_v1_instance_proto_enumTypes,
		MessageInfos:      file_nebius_compute_v1_instance_proto_msgTypes,
	}.Build()
	File_nebius_compute_v1_instance_proto = out.File
	file_nebius_compute_v1_instance_proto_goTypes = nil
	file_nebius_compute_v1_instance_proto_depIdxs = nil
}

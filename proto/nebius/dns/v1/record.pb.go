// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.28.3
// source: nebius/dns/v1/record.proto

package v1

import (
	_ "buf.build/gen/go/bufbuild/protovalidate/protocolbuffers/go/buf/validate"
	_ "github.com/nebius/gosdk/proto/nebius"
	v1 "github.com/nebius/gosdk/proto/nebius/common/v1"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// DNS Record type
type RecordSpec_RecordType int32

const (
	// Record type is not specified
	RecordSpec_RECORD_TYPE_UNSPECIFIED RecordSpec_RecordType = 0
	// `A` record: IPv4 address
	RecordSpec_A RecordSpec_RecordType = 1
	// `AAAA` record: IPv6 address
	RecordSpec_AAAA RecordSpec_RecordType = 2
	// `PTR` record: mapping from IP address to a domain name
	RecordSpec_PTR RecordSpec_RecordType = 3
	// `CNAME` record: an alias for a *canonical domain name*
	RecordSpec_CNAME RecordSpec_RecordType = 4
	// `MX` record: mail server information (domain name, priority)
	RecordSpec_MX RecordSpec_RecordType = 5
	// `TXT` record: text data, typically used to verify e-mail addresses, websites and TLS certificates
	RecordSpec_TXT RecordSpec_RecordType = 6
	// `SRV` record: information about a network service (domain name, port, weight)
	RecordSpec_SRV RecordSpec_RecordType = 7
	// `NS` record: domain name of an authoritative nameserver for this DNS zone, or one of its subzones
	RecordSpec_NS RecordSpec_RecordType = 8
	// `SOA` record: administrative information about this DNS zone
	RecordSpec_SOA RecordSpec_RecordType = 9
	// `CAA` record: certificate issuance settings for this DNS zone and its subzones
	RecordSpec_CAA RecordSpec_RecordType = 10
	// `SVCB` record: service binding. See [RFC 9460, section 2.3](https://www.rfc-editor.org/rfc/rfc9460.html#section-2.3)
	RecordSpec_SVCB RecordSpec_RecordType = 11
	// `HTTPS` record: service binding with HTTPS protocol configuration.
	// See [RFC 9460, section 9.1](https://www.rfc-editor.org/rfc/rfc9460.html#section-9.1)
	RecordSpec_HTTPS RecordSpec_RecordType = 12
)

// Enum value maps for RecordSpec_RecordType.
var (
	RecordSpec_RecordType_name = map[int32]string{
		0:  "RECORD_TYPE_UNSPECIFIED",
		1:  "A",
		2:  "AAAA",
		3:  "PTR",
		4:  "CNAME",
		5:  "MX",
		6:  "TXT",
		7:  "SRV",
		8:  "NS",
		9:  "SOA",
		10: "CAA",
		11: "SVCB",
		12: "HTTPS",
	}
	RecordSpec_RecordType_value = map[string]int32{
		"RECORD_TYPE_UNSPECIFIED": 0,
		"A":                       1,
		"AAAA":                    2,
		"PTR":                     3,
		"CNAME":                   4,
		"MX":                      5,
		"TXT":                     6,
		"SRV":                     7,
		"NS":                      8,
		"SOA":                     9,
		"CAA":                     10,
		"SVCB":                    11,
		"HTTPS":                   12,
	}
)

func (x RecordSpec_RecordType) Enum() *RecordSpec_RecordType {
	p := new(RecordSpec_RecordType)
	*p = x
	return p
}

func (x RecordSpec_RecordType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RecordSpec_RecordType) Descriptor() protoreflect.EnumDescriptor {
	return file_nebius_dns_v1_record_proto_enumTypes[0].Descriptor()
}

func (RecordSpec_RecordType) Type() protoreflect.EnumType {
	return &file_nebius_dns_v1_record_proto_enumTypes[0]
}

func (x RecordSpec_RecordType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RecordSpec_RecordType.Descriptor instead.
func (RecordSpec_RecordType) EnumDescriptor() ([]byte, []int) {
	return file_nebius_dns_v1_record_proto_rawDescGZIP(), []int{1, 0}
}

// API Resource: DNS *Resource Record* (RR), an information entry about a specific domain
//
// Each record is contained within a DNS zone, which is a container for DNS data of a specific domain, and, possibly, its subdomains
// DNS zones are represented in this API by the `Zone` API Resource which is managed by the `ZoneService`
type Record struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// DNS record metadata
	// `metadata.parent_id` must be a DNS zone ID
	Metadata *v1.ResourceMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// DNS record specification, including its relative name, type, data and TTL
	Spec *RecordSpec `protobuf:"bytes,2,opt,name=spec,proto3" json:"spec,omitempty"`
	// DNS record status, including e.g. its effective FQDN (fully-qualified domain name)
	Status        *RecordStatus `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Record) Reset() {
	*x = Record{}
	mi := &file_nebius_dns_v1_record_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Record) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Record) ProtoMessage() {}

func (x *Record) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_dns_v1_record_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Record.ProtoReflect.Descriptor instead.
func (*Record) Descriptor() ([]byte, []int) {
	return file_nebius_dns_v1_record_proto_rawDescGZIP(), []int{0}
}

func (x *Record) GetMetadata() *v1.ResourceMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

func (x *Record) GetSpec() *RecordSpec {
	if x != nil {
		return x.Spec
	}
	return nil
}

func (x *Record) GetStatus() *RecordStatus {
	if x != nil {
		return x.Status
	}
	return nil
}

// DNS record specification
type RecordSpec struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Zone-relative name of this record (e.g., `www` for `www.<parent zone's domain name>`)
	// Use `@` for records in zone apex (that is, records that have the same domain name as the zone itself)
	// To see the resolved absolute domain name, see `Record.status.effective_fqdn`
	RelativeName string `protobuf:"bytes,1,opt,name=relative_name,json=relativeName,proto3" json:"relative_name,omitempty"`
	// Record type
	Type RecordSpec_RecordType `protobuf:"varint,2,opt,name=type,proto3,enum=nebius.dns.v1.RecordSpec_RecordType" json:"type,omitempty"`
	// Record TTL. If absent or negative, will be assumed to be the default value (`600`)
	Ttl int64 `protobuf:"varint,3,opt,name=ttl,proto3" json:"ttl,omitempty"`
	// Record data in text format
	//
	// This should be the RDATA part of this Resource Record's
	// [presentation (zonefile) format](https://datatracker.ietf.org/doc/html/rfc9499#name-resource-records).
	// E.g., `10 xyz.tuv` for a `@ 600 IN MX 10 xyz.tuv.` resource record in a zonefile
	Data string `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	// Mark this record as delete-protected
	// Delete-protected records can *only* be deleted by explicitly calling `RecordService/Delete` API with `force` flag set to `true`
	DeletionProtection bool `protobuf:"varint,6,opt,name=deletion_protection,json=deletionProtection,proto3" json:"deletion_protection,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *RecordSpec) Reset() {
	*x = RecordSpec{}
	mi := &file_nebius_dns_v1_record_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecordSpec) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecordSpec) ProtoMessage() {}

func (x *RecordSpec) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_dns_v1_record_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecordSpec.ProtoReflect.Descriptor instead.
func (*RecordSpec) Descriptor() ([]byte, []int) {
	return file_nebius_dns_v1_record_proto_rawDescGZIP(), []int{1}
}

func (x *RecordSpec) GetRelativeName() string {
	if x != nil {
		return x.RelativeName
	}
	return ""
}

func (x *RecordSpec) GetType() RecordSpec_RecordType {
	if x != nil {
		return x.Type
	}
	return RecordSpec_RECORD_TYPE_UNSPECIFIED
}

func (x *RecordSpec) GetTtl() int64 {
	if x != nil {
		return x.Ttl
	}
	return 0
}

func (x *RecordSpec) GetData() string {
	if x != nil {
		return x.Data
	}
	return ""
}

func (x *RecordSpec) GetDeletionProtection() bool {
	if x != nil {
		return x.DeletionProtection
	}
	return false
}

// DNS record status
type RecordStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Domain name of this record's parent zone including `.` at the end, e.g. `example.com.`
	ZoneDomainName string `protobuf:"bytes,1,opt,name=zone_domain_name,json=zoneDomainName,proto3" json:"zone_domain_name,omitempty"`
	// Fully-qualified domain name of this record including `.` at the end, e.g. `www.example.com.`
	EffectiveFqdn string `protobuf:"bytes,2,opt,name=effective_fqdn,json=effectiveFqdn,proto3" json:"effective_fqdn,omitempty"`
	// Indicates whether there is a running Operation for this Record
	Reconciling   bool `protobuf:"varint,100,opt,name=reconciling,proto3" json:"reconciling,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RecordStatus) Reset() {
	*x = RecordStatus{}
	mi := &file_nebius_dns_v1_record_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RecordStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RecordStatus) ProtoMessage() {}

func (x *RecordStatus) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_dns_v1_record_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RecordStatus.ProtoReflect.Descriptor instead.
func (*RecordStatus) Descriptor() ([]byte, []int) {
	return file_nebius_dns_v1_record_proto_rawDescGZIP(), []int{2}
}

func (x *RecordStatus) GetZoneDomainName() string {
	if x != nil {
		return x.ZoneDomainName
	}
	return ""
}

func (x *RecordStatus) GetEffectiveFqdn() string {
	if x != nil {
		return x.EffectiveFqdn
	}
	return ""
}

func (x *RecordStatus) GetReconciling() bool {
	if x != nil {
		return x.Reconciling
	}
	return false
}

// Request to get the DNS record by its ID and, optionally, its resource version
type GetRecordRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Record ID
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Optional: expected record version (`metadata.resource_version`)
	//   - If specified, the requested version will be returned if possible
	//     (if the version has changed, you will get a `FAILED_PRECONDITION` error)
	//   - If not specified or set to `0`, the latest version will be returned
	ResourceVersion int64 `protobuf:"varint,2,opt,name=resource_version,json=resourceVersion,proto3" json:"resource_version,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetRecordRequest) Reset() {
	*x = GetRecordRequest{}
	mi := &file_nebius_dns_v1_record_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRecordRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRecordRequest) ProtoMessage() {}

func (x *GetRecordRequest) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_dns_v1_record_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRecordRequest.ProtoReflect.Descriptor instead.
func (*GetRecordRequest) Descriptor() ([]byte, []int) {
	return file_nebius_dns_v1_record_proto_rawDescGZIP(), []int{3}
}

func (x *GetRecordRequest) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *GetRecordRequest) GetResourceVersion() int64 {
	if x != nil {
		return x.ResourceVersion
	}
	return 0
}

// Request to list DNS records in the specified parent DNS zone
type ListRecordsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Parent DNS zone ID
	ParentId string `protobuf:"bytes,1,opt,name=parent_id,json=parentId,proto3" json:"parent_id,omitempty"`
	// Page size
	// If not specified or set to `0`, a default page size of `100` will be used
	PageSize int64 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// An opaque listing continuation token
	// - If not specified or empty, the first page of results will be returned
	// - If specified, the next page of results (as identified by the token) will be returned
	PageToken     string `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRecordsRequest) Reset() {
	*x = ListRecordsRequest{}
	mi := &file_nebius_dns_v1_record_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRecordsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRecordsRequest) ProtoMessage() {}

func (x *ListRecordsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_dns_v1_record_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRecordsRequest.ProtoReflect.Descriptor instead.
func (*ListRecordsRequest) Descriptor() ([]byte, []int) {
	return file_nebius_dns_v1_record_proto_rawDescGZIP(), []int{4}
}

func (x *ListRecordsRequest) GetParentId() string {
	if x != nil {
		return x.ParentId
	}
	return ""
}

func (x *ListRecordsRequest) GetPageSize() int64 {
	if x != nil {
		return x.PageSize
	}
	return 0
}

func (x *ListRecordsRequest) GetPageToken() string {
	if x != nil {
		return x.PageToken
	}
	return ""
}

// Response with a single page of DNS record listing results
type ListRecordsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// This page's items
	Items []*Record `protobuf:"bytes,1,rep,name=items,proto3" json:"items,omitempty"`
	// An opaque listing continuation token that can be used to return the next page of listing results
	// If `next_page_token` is empty, this is the last result page
	NextPageToken string `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRecordsResponse) Reset() {
	*x = ListRecordsResponse{}
	mi := &file_nebius_dns_v1_record_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRecordsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRecordsResponse) ProtoMessage() {}

func (x *ListRecordsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_nebius_dns_v1_record_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRecordsResponse.ProtoReflect.Descriptor instead.
func (*ListRecordsResponse) Descriptor() ([]byte, []int) {
	return file_nebius_dns_v1_record_proto_rawDescGZIP(), []int{5}
}

func (x *ListRecordsResponse) GetItems() []*Record {
	if x != nil {
		return x.Items
	}
	return nil
}

func (x *ListRecordsResponse) GetNextPageToken() string {
	if x != nil {
		return x.NextPageToken
	}
	return ""
}

var File_nebius_dns_v1_record_proto protoreflect.FileDescriptor

const file_nebius_dns_v1_record_proto_rawDesc = "" +
	"\n" +
	"\x1anebius/dns/v1/record.proto\x12\rnebius.dns.v1\x1a\x1bbuf/validate/validate.proto\x1a\x18nebius/annotations.proto\x1a\x1fnebius/common/v1/metadata.proto\"\xba\x01\n" +
	"\x06Record\x12L\n" +
	"\bmetadata\x18\x01 \x01(\v2\".nebius.common.v1.ResourceMetadataB\f\xe2J\t\x12\adnszoneR\bmetadata\x12-\n" +
	"\x04spec\x18\x02 \x01(\v2\x19.nebius.dns.v1.RecordSpecR\x04spec\x123\n" +
	"\x06status\x18\x03 \x01(\v2\x1b.nebius.dns.v1.RecordStatusR\x06status\"\x83\x05\n" +
	"\n" +
	"RecordSpec\x12\xb5\x02\n" +
	"\rrelative_name\x18\x01 \x01(\tB\x8f\x02\xbaH\x87\x02\xba\x01\x80\x02\n" +
	"\x14relative_name_format\x12[relative_name must be '@' for zone apex, or a valid relative domain name (e.g. 'a.x-y.zzz')\x1a\x8a\x01size(this) < 253 && this.matches('^(?:@|(?:[*]|[a-z0-9_](?:[a-z0-9-_]{0,60}[a-z0-9_])*)(?:[.][a-z0-9_](?:[a-z0-9-_]{0,60}[a-z0-9_])*)*)$')\xc8\x01\x01\xbaJ\x01\x02R\frelativeName\x12D\n" +
	"\x04type\x18\x02 \x01(\x0e2$.nebius.dns.v1.RecordSpec.RecordTypeB\n" +
	"\xbaH\x03\xc8\x01\x01\xbaJ\x01\x02R\x04type\x12\x10\n" +
	"\x03ttl\x18\x03 \x01(\x03R\x03ttl\x12\x1a\n" +
	"\x04data\x18\x04 \x01(\tB\x06\xbaH\x03\xc8\x01\x01R\x04data\x12/\n" +
	"\x13deletion_protection\x18\x06 \x01(\bR\x12deletionProtection\"\x97\x01\n" +
	"\n" +
	"RecordType\x12\x1b\n" +
	"\x17RECORD_TYPE_UNSPECIFIED\x10\x00\x12\x05\n" +
	"\x01A\x10\x01\x12\b\n" +
	"\x04AAAA\x10\x02\x12\a\n" +
	"\x03PTR\x10\x03\x12\t\n" +
	"\x05CNAME\x10\x04\x12\x06\n" +
	"\x02MX\x10\x05\x12\a\n" +
	"\x03TXT\x10\x06\x12\a\n" +
	"\x03SRV\x10\a\x12\x06\n" +
	"\x02NS\x10\b\x12\a\n" +
	"\x03SOA\x10\t\x12\a\n" +
	"\x03CAA\x10\n" +
	"\x12\b\n" +
	"\x04SVCB\x10\v\x12\t\n" +
	"\x05HTTPS\x10\f\"\x81\x01\n" +
	"\fRecordStatus\x12(\n" +
	"\x10zone_domain_name\x18\x01 \x01(\tR\x0ezoneDomainName\x12%\n" +
	"\x0eeffective_fqdn\x18\x02 \x01(\tR\reffectiveFqdn\x12 \n" +
	"\vreconciling\x18d \x01(\bR\vreconciling\"l\n" +
	"\x10GetRecordRequest\x12$\n" +
	"\x02id\x18\x01 \x01(\tB\x14\xbaH\x03\xc8\x01\x01\xe2J\v\n" +
	"\tdnsrecordR\x02id\x122\n" +
	"\x10resource_version\x18\x02 \x01(\x03B\a\xbaH\x04\"\x02(\x00R\x0fresourceVersion\"\x81\x01\n" +
	"\x12ListRecordsRequest\x12/\n" +
	"\tparent_id\x18\x01 \x01(\tB\x12\xbaH\x03\xc8\x01\x01\xe2J\t\n" +
	"\adnszoneR\bparentId\x12\x1b\n" +
	"\tpage_size\x18\x02 \x01(\x03R\bpageSize\x12\x1d\n" +
	"\n" +
	"page_token\x18\x03 \x01(\tR\tpageToken\"j\n" +
	"\x13ListRecordsResponse\x12+\n" +
	"\x05items\x18\x01 \x03(\v2\x15.nebius.dns.v1.RecordR\x05items\x12&\n" +
	"\x0fnext_page_token\x18\x02 \x01(\tR\rnextPageTokenBR\n" +
	"\x14ai.nebius.pub.dns.v1B\vRecordProtoP\x01Z+github.com/nebius/gosdk/proto/nebius/dns/v1b\x06proto3"

var (
	file_nebius_dns_v1_record_proto_rawDescOnce sync.Once
	file_nebius_dns_v1_record_proto_rawDescData []byte
)

func file_nebius_dns_v1_record_proto_rawDescGZIP() []byte {
	file_nebius_dns_v1_record_proto_rawDescOnce.Do(func() {
		file_nebius_dns_v1_record_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_nebius_dns_v1_record_proto_rawDesc), len(file_nebius_dns_v1_record_proto_rawDesc)))
	})
	return file_nebius_dns_v1_record_proto_rawDescData
}

var file_nebius_dns_v1_record_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_nebius_dns_v1_record_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_nebius_dns_v1_record_proto_goTypes = []any{
	(RecordSpec_RecordType)(0),  // 0: nebius.dns.v1.RecordSpec.RecordType
	(*Record)(nil),              // 1: nebius.dns.v1.Record
	(*RecordSpec)(nil),          // 2: nebius.dns.v1.RecordSpec
	(*RecordStatus)(nil),        // 3: nebius.dns.v1.RecordStatus
	(*GetRecordRequest)(nil),    // 4: nebius.dns.v1.GetRecordRequest
	(*ListRecordsRequest)(nil),  // 5: nebius.dns.v1.ListRecordsRequest
	(*ListRecordsResponse)(nil), // 6: nebius.dns.v1.ListRecordsResponse
	(*v1.ResourceMetadata)(nil), // 7: nebius.common.v1.ResourceMetadata
}
var file_nebius_dns_v1_record_proto_depIdxs = []int32{
	7, // 0: nebius.dns.v1.Record.metadata:type_name -> nebius.common.v1.ResourceMetadata
	2, // 1: nebius.dns.v1.Record.spec:type_name -> nebius.dns.v1.RecordSpec
	3, // 2: nebius.dns.v1.Record.status:type_name -> nebius.dns.v1.RecordStatus
	0, // 3: nebius.dns.v1.RecordSpec.type:type_name -> nebius.dns.v1.RecordSpec.RecordType
	1, // 4: nebius.dns.v1.ListRecordsResponse.items:type_name -> nebius.dns.v1.Record
	5, // [5:5] is the sub-list for method output_type
	5, // [5:5] is the sub-list for method input_type
	5, // [5:5] is the sub-list for extension type_name
	5, // [5:5] is the sub-list for extension extendee
	0, // [0:5] is the sub-list for field type_name
}

func init() { file_nebius_dns_v1_record_proto_init() }
func file_nebius_dns_v1_record_proto_init() {
	if File_nebius_dns_v1_record_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_nebius_dns_v1_record_proto_rawDesc), len(file_nebius_dns_v1_record_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_nebius_dns_v1_record_proto_goTypes,
		DependencyIndexes: file_nebius_dns_v1_record_proto_depIdxs,
		EnumInfos:         file_nebius_dns_v1_record_proto_enumTypes,
		MessageInfos:      file_nebius_dns_v1_record_proto_msgTypes,
	}.Build()
	File_nebius_dns_v1_record_proto = out.File
	file_nebius_dns_v1_record_proto_goTypes = nil
	file_nebius_dns_v1_record_proto_depIdxs = nil
}
